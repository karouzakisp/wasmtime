   Compiling cranelift-codegen v0.109.0 (/home/pk/Documents/ms/hy446/wasmtime/cranelift/codegen)
warning: unused variable: `idom`
   --> cranelift/codegen/src/egraph/elaborate.rs:961:53
    |
961 |                 BlockStackEntry::Elaborate { block, idom } => {
    |                                                     ^^^^ help: try ignoring the field: `idom: _`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: field `before` is never read
  --> cranelift/codegen/src/egraph.rs:39:5
   |
33 | pub struct OrderingInfo {
   |            ------------ field in this struct
...
39 |     before: Option<Inst>,
   |     ^^^^^^
   |
   = note: `OrderingInfo` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: fields `elaborate_visit_node`, `elaborate_memoize_hit`, `elaborate_memoize_miss`, `elaborate_remat`, and `elaborate_licm_hoist` are never read
   --> cranelift/codegen/src/egraph.rs:922:16
    |
911 | pub(crate) struct Stats {
    |                   ----- fields in this struct
...
922 |     pub(crate) elaborate_visit_node: u64,
    |                ^^^^^^^^^^^^^^^^^^^^
923 |     pub(crate) elaborate_memoize_hit: u64,
    |                ^^^^^^^^^^^^^^^^^^^^^
924 |     pub(crate) elaborate_memoize_miss: u64,
    |                ^^^^^^^^^^^^^^^^^^^^^^
925 |     pub(crate) elaborate_remat: u64,
    |                ^^^^^^^^^^^^^^^
926 |     pub(crate) elaborate_licm_hoist: u64,
    |                ^^^^^^^^^^^^^^^^^^^^
    |
    = note: `Stats` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `in_block` is never read
   --> cranelift/codegen/src/egraph/elaborate.rs:123:5
    |
122 | struct ElaboratedValue {
    |        --------------- field in this struct
123 |     in_block: Block,
    |     ^^^^^^^^
    |
    = note: `ElaboratedValue` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `lp`, `hoist_block`, and `scope_depth` are never read
   --> cranelift/codegen/src/egraph/elaborate.rs:130:5
    |
128 | struct LoopStackEntry {
    |        -------------- fields in this struct
129 |     /// The loop identifier.
130 |     lp: Loop,
    |     ^^
...
136 |     hoist_block: Block,
    |     ^^^^^^^^^^^
137 |     /// The depth in the scope map.
138 |     scope_depth: u32,
    |     ^^^^^^^^^^^
    |
    = note: `LoopStackEntry` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: method `insert_if_absent` is never used
   --> cranelift/codegen/src/scoped_hash_map.rs:156:12
    |
86  | / impl<K, V> ScopedHashMap<K, V>
87  | | where
88  | |     K: PartialEq + Eq + Hash + Clone,
    | |_____________________________________- method in this implementation
...
156 |       pub fn insert_if_absent(&mut self, key: K, value: V) {
    |              ^^^^^^^^^^^^^^^^

   Compiling cranelift-module v0.109.0 (/home/pk/Documents/ms/hy446/wasmtime/cranelift/module)
   Compiling cranelift-native v0.109.0 (/home/pk/Documents/ms/hy446/wasmtime/cranelift/native)
   Compiling cranelift-frontend v0.109.0 (/home/pk/Documents/ms/hy446/wasmtime/cranelift/frontend)
   Compiling cranelift-reader v0.109.0 (/home/pk/Documents/ms/hy446/wasmtime/cranelift/reader)
   Compiling cranelift-interpreter v0.109.0 (/home/pk/Documents/ms/hy446/wasmtime/cranelift/interpreter)
   Compiling cranelift-jit v0.109.0 (/home/pk/Documents/ms/hy446/wasmtime/cranelift/jit)
   Compiling cranelift-object v0.109.0 (/home/pk/Documents/ms/hy446/wasmtime/cranelift/object)
   Compiling cranelift v0.109.0 (/home/pk/Documents/ms/hy446/wasmtime/cranelift/umbrella)
   Compiling cranelift-filetests v0.0.0 (/home/pk/Documents/ms/hy446/wasmtime/cranelift/filetests)
warning: `cranelift-codegen` (lib) generated 6 warnings (run `cargo fix --lib -p cranelift-codegen` to apply 1 suggestion)
   Compiling cranelift-tools v0.0.0 (/home/pk/Documents/ms/hy446/wasmtime/cranelift)
    Finished dev [unoptimized + debuginfo] target(s) in 6.64s
     Running `/home/pk/Documents/ms/hy446/wasmtime/target/debug/clif-util run filetests/filetests/egraph/basic-gvn.clif`
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Parsing textual Cranelift IR, (during <no pass>)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Parsing textual Cranelift IR: 0ms
 INFO  cranelift_jit::backend             > defining function funcid0: function u0:0(i32, i32) -> i32 system_v {
block0(v0: i32, v1: i32):
    v2 = iadd v0, v1
    brif v2, block1(v0), block2(v1)

block1(v3: i32):
    v4 = iadd.i32 v0, v1
    v5 = iadd v4, v3
    return v5

block2(v6: i32):
    return v6
}

 DEBUG cranelift_codegen::timing::enabled > timing: Starting Compilation passes, (during <no pass>)
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::context         > Number of CLIF instructions to optimize: 6
 DEBUG cranelift_codegen::context         > Number of CLIF blocks to optimize: 3
 TRACE cranelift_codegen::context         > Optimizing (opt level Speed):
function u0:0(i32, i32) -> i32 system_v {
block0(v0: i32, v1: i32):
    v2 = iadd v0, v1
    brif v2, block1(v0), block2(v1)

block1(v3: i32):
    v4 = iadd.i32 v0, v1
    v5 = iadd v4, v3
    return v5

block2(v6: i32):
    return v6
}

 DEBUG cranelift_codegen::timing::enabled > timing: Starting Control flow graph, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Control flow graph: 0ms
 TRACE cranelift_codegen::legalizer       > Pre-legalization function:
function u0:0(i32, i32) -> i32 system_v {
block0(v0: i32, v1: i32):
    v2 = iadd v0, v1
    brif v2, block1(v0), block2(v1)

block1(v3: i32):
    v4 = iadd.i32 v0, v1
    v5 = iadd v4, v3
    return v5

block2(v6: i32):
    return v6
}

 TRACE cranelift_codegen::legalizer       > Post-legalization function:
function u0:0(i32, i32) -> i32 system_v {
block0(v0: i32, v1: i32):
    v2 = iadd v0, v1
    brif v2, block1(v0), block2(v1)

block1(v3: i32):
    v4 = iadd.i32 v0, v1
    v5 = iadd v4, v3
    return v5

block2(v6: i32):
    return v6
}

 DEBUG cranelift_codegen::timing::enabled > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dominator tree, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Remove unreachable blocks, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Remove unreachable blocks: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dead code elimination, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dead code elimination: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Remove constant phi-nodes, (during Compilation passes)
 DEBUG cranelift_codegen::remove_constant_phis > do_remove_constant_phis: done, 2 iters.   2 formals, of which 2 const.
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove constant phi-nodes: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Egraph based optimizations, (during Compilation passes)
 TRACE cranelift_codegen::context              > About to optimize with egraph phase:
function u0:0(i32, i32) -> i32 system_v {
block0(v0: i32, v1: i32):
    v3 -> v0
    v6 -> v1
    v2 = iadd v0, v1
    brif v2, block1, block2

block1:
    v4 = iadd.i32 v0, v1
    v5 = iadd v4, v3
    return v5

block2:
    return v6
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Loop analysis, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Loop analysis: 0ms
 TRACE cranelift_codegen::alias_analysis       > alias analysis: input is:
function u0:0(i32, i32) -> i32 system_v {
block0(v0: i32, v1: i32):
    v3 -> v0
    v6 -> v1
    v2 = iadd v0, v1
    brif v2, block1, block2

block1:
    v4 = iadd.i32 v0, v1
    v5 = iadd v4, v3
    return v5

block2:
    return v6
}

 TRACE cranelift_codegen::alias_analysis       > alias analysis: input to block0 is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst0: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst1: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > alias analysis: input to block2 is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst5: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > alias analysis: input to block1 is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst2: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst3: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst4: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::egraph               > Processing block block0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for blockparam v0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for blockparam v1
 TRACE cranelift_codegen::egraph               > Processing inst inst0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v2
 TRACE cranelift_codegen::egraph               > rewriting arg v0 of inst inst0 to v0
 TRACE cranelift_codegen::egraph               > rewriting arg v1 of inst inst0 to v1
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v2
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i32
 TRACE cranelift_codegen::opts                 > iter: value v1
 TRACE cranelift_codegen::opts                 > iter: value v0
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v2 -> [v2]
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst1
 TRACE cranelift_codegen::egraph               > rewriting arg v2 of inst inst1 to v2
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst1 with state LastStores { heap: None, table: None, vmctx: None, other: None } (Brif { opcode: Brif, arg: v2, blocks: [BlockCall { values: EntityList { index: 33, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }, BlockCall { values: EntityList { index: 17, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }] })
 TRACE cranelift_codegen::egraph               > Processing block block1
 TRACE cranelift_codegen::egraph               > Processing inst inst2
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v4
 TRACE cranelift_codegen::egraph               > rewriting arg v0 of inst inst2 to v0
 TRACE cranelift_codegen::egraph               > rewriting arg v1 of inst inst2 to v1
 TRACE cranelift_codegen::egraph               > Processing inst inst3
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v5
 TRACE cranelift_codegen::egraph               > rewriting arg v4 of inst inst3 to v2
 TRACE cranelift_codegen::egraph               > rewriting arg v0 of inst inst3 to v0
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v5
 TRACE cranelift_codegen::opts                 > iter: value v5
 TRACE cranelift_codegen::opts                 >  -> value of type i32
 TRACE cranelift_codegen::opts                 > iter: value v0
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i32
 TRACE cranelift_codegen::opts                 > iter: value v0
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v5 -> [v5]
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst4
 TRACE cranelift_codegen::egraph               > rewriting arg v5 of inst inst4 to v5
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst4 with state LastStores { heap: None, table: None, vmctx: None, other: None } (MultiAry { opcode: Return, args: EntityList { index: 29, unused: PhantomData<cranelift_codegen::ir::entities::Value> } })
 TRACE cranelift_codegen::egraph               > Processing block block2
 TRACE cranelift_codegen::egraph               > Processing inst inst5
 TRACE cranelift_codegen::egraph               > rewriting arg v1 of inst inst5 to v1
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst5 with state LastStores { heap: None, table: None, vmctx: None, other: None } (MultiAry { opcode: Return, args: EntityList { index: 37, unused: PhantomData<cranelift_codegen::ir::entities::Value> } })
 TRACE cranelift_codegen::egraph               > egraph built:
function u0:0(i32, i32) -> i32 system_v {
block0(v0: i32, v1: i32):
    brif.i32 v2, block1, block2

block1:
    return v5

block2:
    return v1
}


 TRACE cranelift_codegen::egraph               >  -> v0 = Param(block0, 0)
 TRACE cranelift_codegen::egraph               >  -> v1 = Param(block0, 1)
 TRACE cranelift_codegen::egraph               >  -> v2 = Result(inst0, 0)
 TRACE cranelift_codegen::egraph               >   -> inst0 = Binary { opcode: Iadd, args: [v0, v1] }
 TRACE cranelift_codegen::egraph               >  -> v4 = Result(inst2, 0)
 TRACE cranelift_codegen::egraph               >   -> inst2 = Binary { opcode: Iadd, args: [v0, v1] }
 TRACE cranelift_codegen::egraph               >  -> v5 = Result(inst3, 0)
 TRACE cranelift_codegen::egraph               >   -> inst3 = Binary { opcode: Iadd, args: [v2, v0] }
 TRACE cranelift_codegen::egraph               > stats: Stats {
    pure_inst: 3,
    pure_inst_deduped: 1,
    skeleton_inst: 3,
    alias_analysis_removed: 0,
    new_inst: 0,
    union: 0,
    subsume: 0,
    remat: 0,
    rewrite_rule_invoked: 2,
    rewrite_depth_limit: 0,
    elaborate_visit_node: 0,
    elaborate_memoize_hit: 0,
    elaborate_memoize_miss: 0,
    elaborate_remat: 0,
    elaborate_licm_hoist: 0,
    elaborate_func: 0,
    elaborate_func_pre_insts: 0,
    elaborate_func_post_insts: 0,
    elaborate_best_cost_fixpoint_iters: 0,
}
 TRACE cranelift_codegen::egraph               > pinned_union_count: 0
 TRACE cranelift_codegen::egraph::elaborate    > Entering fixpoint loop to compute the best values for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 0
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v0 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 1)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v2 = Cost::Finite { op_cost: 3, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v4 def Result(inst2, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v4 = Cost::Finite { op_cost: 3, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v5 def Result(inst3, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v5 = Cost::Finite { op_cost: 6, depth: 2 }
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 1
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v0 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 1)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v2 = Cost::Finite { op_cost: 3, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v4 def Result(inst2, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v4 = Cost::Finite { op_cost: 3, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v5 def Result(inst3, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v5 = Cost::Finite { op_cost: 6, depth: 2 }
 TRACE cranelift_codegen::egraph::elaborate    > finished fixpoint loop to compute best value for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v0: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v0)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v1: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v1)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v2: BestEntry(Cost::Finite { op_cost: 3, depth: 1 }, v2)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v4: BestEntry(Cost::Finite { op_cost: 3, depth: 1 }, v4)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v5: BestEntry(Cost::Finite { op_cost: 6, depth: 2 }, v5)
 TRACE cranelift_codegen::egraph::elaborate    > add_skeleton_dependences:: dependency count before increment for inst inst1 is 0
 TRACE cranelift_codegen::egraph::elaborate    > add_skeleton_dependencies:: dependency count before decrement for first inst inst1 is 1
 TRACE cranelift_codegen::egraph::elaborate    > computeDDG: dependency count after increment for inst inst1 is 1
 TRACE cranelift_codegen::egraph::elaborate    > need inst inst0 before inst1
 TRACE cranelift_codegen::egraph::elaborate    >  -> no location; using original inst
 TRACE cranelift_codegen::egraph::elaborate    >  -> inserting identity mapping for v2
 TRACE cranelift_codegen::egraph::elaborate    > schedule_insts: true data dependency : result_user_inst v2 for inserted inst inst0 dependency count before decrement for user_inst inst1 is 1
 TRACE cranelift_codegen::egraph::elaborate    >  -> Terminator elab arg v2 is best value is v2
 TRACE cranelift_codegen::egraph::elaborate    > add_skeleton_dependences:: dependency count before increment for inst inst5 is 0
 TRACE cranelift_codegen::egraph::elaborate    > add_skeleton_dependencies:: dependency count before decrement for first inst inst5 is 1
 TRACE cranelift_codegen::egraph::elaborate    >  -> Terminator elab arg v1 is best value is v1
 TRACE cranelift_codegen::egraph::elaborate    > add_skeleton_dependences:: dependency count before increment for inst inst4 is 0
 TRACE cranelift_codegen::egraph::elaborate    > add_skeleton_dependencies:: dependency count before decrement for first inst inst4 is 1
 TRACE cranelift_codegen::egraph::elaborate    > computeDDG: dependency count after increment for inst inst4 is 1
 TRACE cranelift_codegen::egraph::elaborate    > computeDDG: dependency count after increment for inst inst3 is 1
 TRACE cranelift_codegen::egraph::elaborate    > need inst inst0 before inst4
 TRACE cranelift_codegen::egraph::elaborate    > schedule_insts: true data dependency : result_user_inst v2 for inserted inst inst0 dependency count before decrement for user_inst inst1 is 0
thread 'main' panicked at cranelift/codegen/src/egraph/elaborate.rs:855:21:
attempt to subtract with overflow
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Egraph based optimizations: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Compilation passes: 0ms
