warning: unused import: `alloc::borrow::ToOwned`
  --> cranelift/codegen/src/egraph/elaborate.rs:15:5
   |
15 | use alloc::borrow::ToOwned;
   |     ^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused variable: `idom`
   --> cranelift/codegen/src/egraph/elaborate.rs:903:53
    |
903 |                 BlockStackEntry::Elaborate { block, idom } => {
    |                                                     ^^^^ help: try ignoring the field: `idom: _`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: field `before` is never read
  --> cranelift/codegen/src/egraph.rs:39:5
   |
33 | pub struct OrderingInfo {
   |            ------------ field in this struct
...
39 |     before: Option<Inst>,
   |     ^^^^^^
   |
   = note: `OrderingInfo` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: fields `elaborate_visit_node`, `elaborate_memoize_hit`, `elaborate_memoize_miss`, `elaborate_remat`, and `elaborate_licm_hoist` are never read
   --> cranelift/codegen/src/egraph.rs:922:16
    |
911 | pub(crate) struct Stats {
    |                   ----- fields in this struct
...
922 |     pub(crate) elaborate_visit_node: u64,
    |                ^^^^^^^^^^^^^^^^^^^^
923 |     pub(crate) elaborate_memoize_hit: u64,
    |                ^^^^^^^^^^^^^^^^^^^^^
924 |     pub(crate) elaborate_memoize_miss: u64,
    |                ^^^^^^^^^^^^^^^^^^^^^^
925 |     pub(crate) elaborate_remat: u64,
    |                ^^^^^^^^^^^^^^^
926 |     pub(crate) elaborate_licm_hoist: u64,
    |                ^^^^^^^^^^^^^^^^^^^^
    |
    = note: `Stats` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `loop_analysis`, `loop_stack`, `cur_block`, `remat_values`, `elab_result_stack`, and `remat_copies` are never read
  --> cranelift/codegen/src/egraph/elaborate.rs:26:5
   |
23 | pub(crate) struct Elaborator<'a> {
   |                   ---------- fields in this struct
...
26 |     loop_analysis: &'a LoopAnalysis,
   |     ^^^^^^^^^^^^^
...
54 |     loop_stack: SmallVec<[LoopStackEntry; 8]>,
   |     ^^^^^^^^^^
55 |     /// The current block into which we are elaborating.
56 |     cur_block: Block,
   |     ^^^^^^^^^
...
60 |     remat_values: &'a FxHashSet<Value>,
   |     ^^^^^^^^^^^^
61 |     /// Results from the elab stack.
62 |     elab_result_stack: Vec<ElaboratedValue>,
   |     ^^^^^^^^^^^^^^^^^
...
66 |     remat_copies: FxHashMap<(Block, Value), Value>,
   |     ^^^^^^^^^^^^

warning: field `in_block` is never read
   --> cranelift/codegen/src/egraph/elaborate.rs:124:5
    |
123 | struct ElaboratedValue {
    |        --------------- field in this struct
124 |     in_block: Block,
    |     ^^^^^^^^
    |
    = note: `ElaboratedValue` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `lp`, `hoist_block`, and `scope_depth` are never read
   --> cranelift/codegen/src/egraph/elaborate.rs:131:5
    |
129 | struct LoopStackEntry {
    |        -------------- fields in this struct
130 |     /// The loop identifier.
131 |     lp: Loop,
    |     ^^
...
137 |     hoist_block: Block,
    |     ^^^^^^^^^^^
138 |     /// The depth in the scope map.
139 |     scope_depth: u32,
    |     ^^^^^^^^^^^
    |
    = note: `LoopStackEntry` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: method `insert_if_absent` is never used
   --> cranelift/codegen/src/scoped_hash_map.rs:156:12
    |
86  | / impl<K, V> ScopedHashMap<K, V>
87  | | where
88  | |     K: PartialEq + Eq + Hash + Clone,
    | |_____________________________________- method in this implementation
...
156 |       pub fn insert_if_absent(&mut self, key: K, value: V) {
    |              ^^^^^^^^^^^^^^^^

warning: `cranelift-codegen` (lib) generated 8 warnings (run `cargo fix --lib -p cranelift-codegen` to apply 2 suggestions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.06s
     Running `/home/pk/Documents/ms/hy446/wasmtime/target/debug/clif-util run filetests/filetests/egraph/extends.clif -- extend_always_above_zero`
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Parsing textual Cranelift IR, (during <no pass>)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Parsing textual Cranelift IR: 0ms
 INFO  cranelift_jit::backend             > defining function funcid0: function u0:0() -> i64 system_v {
block0:
    v0 = iconst.i32 0x9876_5432
    v1 = uextend.i64 v0  ; v0 = 0x9876_5432
    return v1
}

 DEBUG cranelift_codegen::timing::enabled > timing: Starting Compilation passes, (during <no pass>)
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::context         > Number of CLIF instructions to optimize: 3
 DEBUG cranelift_codegen::context         > Number of CLIF blocks to optimize: 1
 TRACE cranelift_codegen::context         > Optimizing (opt level Speed):
function u0:0() -> i64 system_v {
block0:
    v0 = iconst.i32 0x9876_5432
    v1 = uextend.i64 v0  ; v0 = 0x9876_5432
    return v1
}

 DEBUG cranelift_codegen::timing::enabled > timing: Starting Control flow graph, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Control flow graph: 0ms
 TRACE cranelift_codegen::legalizer       > Pre-legalization function:
function u0:0() -> i64 system_v {
block0:
    v0 = iconst.i32 0x9876_5432
    v1 = uextend.i64 v0  ; v0 = 0x9876_5432
    return v1
}

 TRACE cranelift_codegen::legalizer       > Post-legalization function:
function u0:0() -> i64 system_v {
block0:
    v0 = iconst.i32 0x9876_5432
    v1 = uextend.i64 v0  ; v0 = 0x9876_5432
    return v1
}

 DEBUG cranelift_codegen::timing::enabled > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dominator tree, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Remove unreachable blocks, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Remove unreachable blocks: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dead code elimination, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dead code elimination: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled > timing: Starting Remove constant phi-nodes, (during Compilation passes)
 DEBUG cranelift_codegen::remove_constant_phis > do_remove_constant_phis: done, 1 iters.   0 formals, of which 0 const.
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove constant phi-nodes: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Egraph based optimizations, (during Compilation passes)
 TRACE cranelift_codegen::context              > About to optimize with egraph phase:
function u0:0() -> i64 system_v {
block0:
    v0 = iconst.i32 0x9876_5432
    v1 = uextend.i64 v0  ; v0 = 0x9876_5432
    return v1
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Loop analysis, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Loop analysis: 0ms
 TRACE cranelift_codegen::alias_analysis       > alias analysis: input is:
function u0:0() -> i64 system_v {
block0:
    v0 = iconst.i32 0x9876_5432
    v1 = uextend.i64 v0  ; v0 = 0x9876_5432
    return v1
}

 TRACE cranelift_codegen::alias_analysis       > alias analysis: input to block0 is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst0: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst1: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst2: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::egraph               > Processing block block0
 TRACE cranelift_codegen::egraph               > Processing inst inst0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v0
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v0
 TRACE cranelift_codegen::opts                 > iter: value v0
 TRACE cranelift_codegen::opts                 >  -> value of type i32
 TRACE cranelift_codegen::opts                 > remat: v0
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v0 -> [v0, v0]
 TRACE cranelift_codegen::egraph               > Returned from ISLE for v0, got v0
 TRACE cranelift_codegen::egraph               >  -> same as orig value; skipping
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst1
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v1
 TRACE cranelift_codegen::egraph               > rewriting arg v0 of inst inst1 to v0
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v1
 TRACE cranelift_codegen::opts                 > iter: value v1
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > iter: value v0
 TRACE cranelift_codegen::opts                 >  -> value of type i32
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 2
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v2
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > remat: v2
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v2 -> [v2, v2]
 TRACE cranelift_codegen::egraph               > Returned from ISLE for v2, got v2
 TRACE cranelift_codegen::egraph               >  -> same as orig value; skipping
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 1
 TRACE cranelift_codegen::opts                 > make_inst_ctor: UnaryImm { opcode: Iconst, imm: Imm64(2557891634) } -> v2
 TRACE cranelift_codegen::opts                 > subsume: v2
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v1 -> [v2, v1]
 TRACE cranelift_codegen::egraph               > Returned from ISLE for v1, got v2
 TRACE cranelift_codegen::unionfind            > union: v2, v1
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst2
 TRACE cranelift_codegen::egraph               > rewriting arg v1 of inst inst2 to v2
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst2 with state LastStores { heap: None, table: None, vmctx: None, other: None } (MultiAry { opcode: Return, args: EntityList { index: 9, unused: PhantomData<cranelift_codegen::ir::entities::Value> } })
 TRACE cranelift_codegen::egraph               > egraph built:
function u0:0() -> i64 system_v {
block0:
    return v2  ; v2 = 0x9876_5432
}


 TRACE cranelift_codegen::egraph               >  -> v0 = Result(inst0, 0)
 TRACE cranelift_codegen::egraph               >   -> inst0 = UnaryImm { opcode: Iconst, imm: Imm64(2557891634) }
 TRACE cranelift_codegen::egraph               >  -> v1 = Result(inst1, 0)
 TRACE cranelift_codegen::egraph               >   -> inst1 = Unary { opcode: Uextend, arg: v0 }
 TRACE cranelift_codegen::egraph               >  -> v2 = Result(inst3, 0)
 TRACE cranelift_codegen::egraph               >   -> inst3 = UnaryImm { opcode: Iconst, imm: Imm64(2557891634) }
 TRACE cranelift_codegen::egraph               > stats: Stats {
    pure_inst: 3,
    pure_inst_deduped: 0,
    skeleton_inst: 1,
    alias_analysis_removed: 0,
    new_inst: 1,
    union: 0,
    subsume: 1,
    remat: 2,
    rewrite_rule_invoked: 3,
    rewrite_depth_limit: 0,
    elaborate_visit_node: 0,
    elaborate_memoize_hit: 0,
    elaborate_memoize_miss: 0,
    elaborate_remat: 0,
    elaborate_licm_hoist: 0,
    elaborate_func: 0,
    elaborate_func_pre_insts: 0,
    elaborate_func_post_insts: 0,
    elaborate_best_cost_fixpoint_iters: 0,
}
 TRACE cranelift_codegen::egraph               > pinned_union_count: 0
 TRACE cranelift_codegen::egraph::elaborate    > Entering fixpoint loop to compute the best values for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 0
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v0 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v0 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Result(inst1, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v1 = Cost::Finite { op_cost: 3, depth: 2 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst3, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v2 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 1
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v0 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v0 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Result(inst1, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v1 = Cost::Finite { op_cost: 3, depth: 2 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst3, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v2 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > finished fixpoint loop to compute best value for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v0: BestEntry(Cost::Finite { op_cost: 1, depth: 1 }, v0)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v1: BestEntry(Cost::Finite { op_cost: 3, depth: 2 }, v1)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v2: BestEntry(Cost::Finite { op_cost: 1, depth: 1 }, v2)
 TRACE cranelift_codegen::egraph::elaborate    > need inst inst3 before inst2
 TRACE cranelift_codegen::egraph::elaborate    >  -> no location; using original inst
 TRACE cranelift_codegen::egraph::elaborate    >  -> inserting identity mapping for v2
 TRACE cranelift_codegen::egraph::elaborate    >  -> Terminator elab arg v2 is best value is v2
 DEBUG cranelift_codegen::context              > egraph stats: Stats { pure_inst: 3, pure_inst_deduped: 0, skeleton_inst: 1, alias_analysis_removed: 0, new_inst: 1, union: 0, subsume: 1, remat: 2, rewrite_rule_invoked: 3, rewrite_depth_limit: 0, elaborate_visit_node: 0, elaborate_memoize_hit: 0, elaborate_memoize_miss: 0, elaborate_remat: 0, elaborate_licm_hoist: 0, elaborate_func: 1, elaborate_func_pre_insts: 4, elaborate_func_post_insts: 4, elaborate_best_cost_fixpoint_iters: 2 }
 TRACE cranelift_codegen::context              > pinned_union_count: 0
 TRACE cranelift_codegen::context              > After egraph optimization:
function u0:0() -> i64 system_v {
block0:
    v2 = iconst.i64 0x9876_5432
    return v2  ; v2 = 0x9876_5432
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Egraph based optimizations: 0ms
 TRACE cranelift_codegen::machinst::abi        > ABISig: sig Signature { params: [], returns: [AbiParam { value_type: types::I64, purpose: Normal, extension: None }], call_conv: SystemV } => args end = 1 rets end = 1
             arg stack = 0 ret stack = 0 stack_ret_arg = false
 TRACE cranelift_codegen::machinst::abi        > ABI: func signature Signature { params: [], returns: [AbiParam { value_type: types::I64, purpose: Normal, extension: None }], call_conv: SystemV }
 TRACE cranelift_codegen::machinst::blockorder > BlockLoweringOrder: function body function u0:0() -> i64 system_v {
block0:
    v2 = iconst.i64 0x9876_5432
    return v2  ; v2 = 0x9876_5432
}

 TRACE cranelift_codegen::machinst::blockorder > BlockLoweringOrder: BlockLoweringOrder {
    lowered_order: [
        Orig {
            block: block0,
        },
    ],
    lowered_succ_indices: [],
    lowered_succ_ranges: [
        (
            None,
            0..0,
        ),
    ],
    cold_blocks: {},
    indirect_branch_targets: {},
}
 TRACE cranelift_codegen::machinst::lower      > bb block0 inst inst3 (UnaryImm { opcode: Iconst, imm: Imm64(2557891634) }): result v2 regs ValueRegs { parts: [v192, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > bb block0 inst inst3 has color 1
 TRACE cranelift_codegen::machinst::lower      >  -> constant: 2557891634
 TRACE cranelift_codegen::machinst::lower      > bb block0 inst inst2 has color 1
 TRACE cranelift_codegen::machinst::lower      >  -> side-effecting; incrementing color for next inst
 TRACE cranelift_codegen::machinst::lower      > arg v2 used, old state Unused, new Once
 DEBUG cranelift_codegen::machinst::compile    > Number of CLIF instructions to lower: 4
 DEBUG cranelift_codegen::machinst::compile    > Number of CLIF blocks to lower: 1
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode lowering, (during Compilation passes)
 TRACE cranelift_codegen::machinst::lower      > about to lower function: function u0:0() -> i64 system_v {
block0:
    v2 = iconst.i64 0x9876_5432
    return v2  ; v2 = 0x9876_5432
}

 TRACE cranelift_codegen::machinst::lower      > lower_clif_block: block block0 inst inst2 (MultiAry { opcode: Return, args: EntityList { index: 9, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }) is_branch false side_effect true value_needed false
 TRACE cranelift_codegen::machinst::lower      > lowering: inst inst2: MultiAry { opcode: Return, args: EntityList { index: 9, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }
 TRACE cranelift_codegen::machinst::lower      > put_value_in_regs: val v2
 TRACE cranelift_codegen::machinst::lower      >  -> regs ValueRegs { parts: [v192, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > emit: rets %v192=%rax
 TRACE cranelift_codegen::machinst::lower      > lower_clif_block: block block0 inst inst3 (UnaryImm { opcode: Iconst, imm: Imm64(2557891634) }) is_branch false side_effect false value_needed true
 TRACE cranelift_codegen::machinst::lower      > lowering: inst inst3: UnaryImm { opcode: Iconst, imm: Imm64(2557891634) }
 TRACE cranelift_codegen::machinst::lower      > emit: movl    $-1737075662, %v193l
 TRACE cranelift_codegen::machinst::lower      > set vreg alias: v2 = v192, lowering = v193
 TRACE cranelift_codegen::machinst::lower      > gen_arg_setup: entry BB block0 args are:
[]
 TRACE cranelift_codegen::machinst::abi        > gen_retval_area_setup: not needed
 TRACE cranelift_codegen::machinst::lower      > built vcode:
VRegAllocator {
  v192 := v193
}
Backwards VCode {
  Entry block: 0
Block 0:
    (original IR block: block0)
  Inst 0: rets %v192=%rax
  Inst 1: movl    $-1737075662, %v193l
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode lowering: 0ms
 DEBUG cranelift_codegen::machinst::compile    > Number of lowered vcode instructions: 2
 DEBUG cranelift_codegen::machinst::compile    > Number of lowered vcode blocks: 1
 TRACE cranelift_codegen::machinst::compile    > vcode from lowering: 
VCode {
  Entry block: 0
Block 0:
    (original IR block: block0)
  Inst 0: movl    $-1737075662, %v193l
  Inst 1: rets %v193=%rax
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Register allocation, (during Compilation passes)
 TRACE regalloc2::ion::liveranges              > computing liveins for block0
 TRACE regalloc2::ion::liveranges              >  -> initial liveout set: []
 TRACE regalloc2::ion::liveranges              > op Use: v193i fixed(p0i) was_live = false
 TRACE regalloc2::ion::liveranges              > op Def: v193i reg was_live = true
 TRACE regalloc2::ion::liveranges              > computed liveins at block0: []
 TRACE regalloc2::ion::liveranges              > processing inst1 operand at progpoint1-pre: Use: v193i fixed(p0i)
 TRACE regalloc2::ion::liveranges              > add_liverange_to_vreg: vreg VRegIndex(193) range CodeRange { from: progpoint0-pre, to: progpoint1-post }
 TRACE regalloc2::ion::liveranges              > Use of Use: v193i fixed(p0i) at progpoint1-pre -> LiveRangeIndex(0)
 TRACE regalloc2::ion::liveranges              > insert use Use { operand: Use: v193i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 } into lr LiveRangeIndex(0) with weight SpillWeight(3000.0)
 TRACE regalloc2::ion::liveranges              >   -> now range has weight SpillWeight(3000.0)
 TRACE regalloc2::ion::liveranges              > processing inst0 operand at progpoint0-post: Def: v193i reg
 TRACE regalloc2::ion::liveranges              > Def of v193 at progpoint0-post
 TRACE regalloc2::ion::liveranges              >  -> has existing LR LiveRangeIndex(0)
 TRACE regalloc2::ion::liveranges              > insert use Use { operand: Def: v193i reg, pos: progpoint0-post, slot: 0, weight: 35640 } into lr LiveRangeIndex(0) with weight SpillWeight(5000.0)
 TRACE regalloc2::ion::liveranges              >   -> now range has weight SpillWeight(8000.0)
 TRACE regalloc2::ion::liveranges              >  -> started at block start; trimming to progpoint0-post
 TRACE regalloc2::ion::liveranges              > multi-fixed-reg cleanup: vreg VRegIndex(193) range LiveRangeIndex(0)
 TRACE regalloc2::ion::merge                   > merge_vreg_bundles: creating vreg bundles
 TRACE regalloc2::ion::merge                   > vreg v193 gets bundle0
 TRACE regalloc2::ion::merge                   >  -> with LR range0: CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::merge                   > done merging bundles
 TRACE regalloc2::ion::merge                   > enqueueing bundle0
 TRACE regalloc2::ion::merge                   >  -> prio 1
 TRACE regalloc2::ion::process                 > recompute bundle properties: bundle LiveBundleIndex(0)
 TRACE regalloc2::ion::process                 >   -> use: Use { operand: Def: v193i reg, pos: progpoint0-post, slot: 0, weight: 35640 }
 TRACE regalloc2::ion::process                 >   -> use: Use { operand: Use: v193i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 }
 TRACE regalloc2::ion::process                 >   -> fixed operand at progpoint1-pre: Use: v193i fixed(p0i)
 TRACE regalloc2::ion::process                 >   -> first range has range CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::process                 >   -> minimal: false
 TRACE regalloc2::ion::process                 >   -> uses spill weight: +SpillWeight(8000.0)
 TRACE regalloc2::ion::process                 >  -> dividing by prio 1; final weight 8000
 TRACE regalloc2::ion::dump                    > Bundles:
 TRACE regalloc2::ion::dump                    > bundle0: spillset=SpillSetIndex(0) alloc=none
 TRACE regalloc2::ion::dump                    >  * range progpoint0-post -- progpoint1-post: range0
 TRACE regalloc2::ion::dump                    > VRegs:
 TRACE regalloc2::ion::dump                    > vreg0:
 TRACE regalloc2::ion::dump                    > vreg1:
 TRACE regalloc2::ion::dump                    > vreg2:
 TRACE regalloc2::ion::dump                    > vreg3:
 TRACE regalloc2::ion::dump                    > vreg4:
 TRACE regalloc2::ion::dump                    > vreg5:
 TRACE regalloc2::ion::dump                    > vreg6:
 TRACE regalloc2::ion::dump                    > vreg7:
 TRACE regalloc2::ion::dump                    > vreg8:
 TRACE regalloc2::ion::dump                    > vreg9:
 TRACE regalloc2::ion::dump                    > vreg10:
 TRACE regalloc2::ion::dump                    > vreg11:
 TRACE regalloc2::ion::dump                    > vreg12:
 TRACE regalloc2::ion::dump                    > vreg13:
 TRACE regalloc2::ion::dump                    > vreg14:
 TRACE regalloc2::ion::dump                    > vreg15:
 TRACE regalloc2::ion::dump                    > vreg16:
 TRACE regalloc2::ion::dump                    > vreg17:
 TRACE regalloc2::ion::dump                    > vreg18:
 TRACE regalloc2::ion::dump                    > vreg19:
 TRACE regalloc2::ion::dump                    > vreg20:
 TRACE regalloc2::ion::dump                    > vreg21:
 TRACE regalloc2::ion::dump                    > vreg22:
 TRACE regalloc2::ion::dump                    > vreg23:
 TRACE regalloc2::ion::dump                    > vreg24:
 TRACE regalloc2::ion::dump                    > vreg25:
 TRACE regalloc2::ion::dump                    > vreg26:
 TRACE regalloc2::ion::dump                    > vreg27:
 TRACE regalloc2::ion::dump                    > vreg28:
 TRACE regalloc2::ion::dump                    > vreg29:
 TRACE regalloc2::ion::dump                    > vreg30:
 TRACE regalloc2::ion::dump                    > vreg31:
 TRACE regalloc2::ion::dump                    > vreg32:
 TRACE regalloc2::ion::dump                    > vreg33:
 TRACE regalloc2::ion::dump                    > vreg34:
 TRACE regalloc2::ion::dump                    > vreg35:
 TRACE regalloc2::ion::dump                    > vreg36:
 TRACE regalloc2::ion::dump                    > vreg37:
 TRACE regalloc2::ion::dump                    > vreg38:
 TRACE regalloc2::ion::dump                    > vreg39:
 TRACE regalloc2::ion::dump                    > vreg40:
 TRACE regalloc2::ion::dump                    > vreg41:
 TRACE regalloc2::ion::dump                    > vreg42:
 TRACE regalloc2::ion::dump                    > vreg43:
 TRACE regalloc2::ion::dump                    > vreg44:
 TRACE regalloc2::ion::dump                    > vreg45:
 TRACE regalloc2::ion::dump                    > vreg46:
 TRACE regalloc2::ion::dump                    > vreg47:
 TRACE regalloc2::ion::dump                    > vreg48:
 TRACE regalloc2::ion::dump                    > vreg49:
 TRACE regalloc2::ion::dump                    > vreg50:
 TRACE regalloc2::ion::dump                    > vreg51:
 TRACE regalloc2::ion::dump                    > vreg52:
 TRACE regalloc2::ion::dump                    > vreg53:
 TRACE regalloc2::ion::dump                    > vreg54:
 TRACE regalloc2::ion::dump                    > vreg55:
 TRACE regalloc2::ion::dump                    > vreg56:
 TRACE regalloc2::ion::dump                    > vreg57:
 TRACE regalloc2::ion::dump                    > vreg58:
 TRACE regalloc2::ion::dump                    > vreg59:
 TRACE regalloc2::ion::dump                    > vreg60:
 TRACE regalloc2::ion::dump                    > vreg61:
 TRACE regalloc2::ion::dump                    > vreg62:
 TRACE regalloc2::ion::dump                    > vreg63:
 TRACE regalloc2::ion::dump                    > vreg64:
 TRACE regalloc2::ion::dump                    > vreg65:
 TRACE regalloc2::ion::dump                    > vreg66:
 TRACE regalloc2::ion::dump                    > vreg67:
 TRACE regalloc2::ion::dump                    > vreg68:
 TRACE regalloc2::ion::dump                    > vreg69:
 TRACE regalloc2::ion::dump                    > vreg70:
 TRACE regalloc2::ion::dump                    > vreg71:
 TRACE regalloc2::ion::dump                    > vreg72:
 TRACE regalloc2::ion::dump                    > vreg73:
 TRACE regalloc2::ion::dump                    > vreg74:
 TRACE regalloc2::ion::dump                    > vreg75:
 TRACE regalloc2::ion::dump                    > vreg76:
 TRACE regalloc2::ion::dump                    > vreg77:
 TRACE regalloc2::ion::dump                    > vreg78:
 TRACE regalloc2::ion::dump                    > vreg79:
 TRACE regalloc2::ion::dump                    > vreg80:
 TRACE regalloc2::ion::dump                    > vreg81:
 TRACE regalloc2::ion::dump                    > vreg82:
 TRACE regalloc2::ion::dump                    > vreg83:
 TRACE regalloc2::ion::dump                    > vreg84:
 TRACE regalloc2::ion::dump                    > vreg85:
 TRACE regalloc2::ion::dump                    > vreg86:
 TRACE regalloc2::ion::dump                    > vreg87:
 TRACE regalloc2::ion::dump                    > vreg88:
 TRACE regalloc2::ion::dump                    > vreg89:
 TRACE regalloc2::ion::dump                    > vreg90:
 TRACE regalloc2::ion::dump                    > vreg91:
 TRACE regalloc2::ion::dump                    > vreg92:
 TRACE regalloc2::ion::dump                    > vreg93:
 TRACE regalloc2::ion::dump                    > vreg94:
 TRACE regalloc2::ion::dump                    > vreg95:
 TRACE regalloc2::ion::dump                    > vreg96:
 TRACE regalloc2::ion::dump                    > vreg97:
 TRACE regalloc2::ion::dump                    > vreg98:
 TRACE regalloc2::ion::dump                    > vreg99:
 TRACE regalloc2::ion::dump                    > vreg100:
 TRACE regalloc2::ion::dump                    > vreg101:
 TRACE regalloc2::ion::dump                    > vreg102:
 TRACE regalloc2::ion::dump                    > vreg103:
 TRACE regalloc2::ion::dump                    > vreg104:
 TRACE regalloc2::ion::dump                    > vreg105:
 TRACE regalloc2::ion::dump                    > vreg106:
 TRACE regalloc2::ion::dump                    > vreg107:
 TRACE regalloc2::ion::dump                    > vreg108:
 TRACE regalloc2::ion::dump                    > vreg109:
 TRACE regalloc2::ion::dump                    > vreg110:
 TRACE regalloc2::ion::dump                    > vreg111:
 TRACE regalloc2::ion::dump                    > vreg112:
 TRACE regalloc2::ion::dump                    > vreg113:
 TRACE regalloc2::ion::dump                    > vreg114:
 TRACE regalloc2::ion::dump                    > vreg115:
 TRACE regalloc2::ion::dump                    > vreg116:
 TRACE regalloc2::ion::dump                    > vreg117:
 TRACE regalloc2::ion::dump                    > vreg118:
 TRACE regalloc2::ion::dump                    > vreg119:
 TRACE regalloc2::ion::dump                    > vreg120:
 TRACE regalloc2::ion::dump                    > vreg121:
 TRACE regalloc2::ion::dump                    > vreg122:
 TRACE regalloc2::ion::dump                    > vreg123:
 TRACE regalloc2::ion::dump                    > vreg124:
 TRACE regalloc2::ion::dump                    > vreg125:
 TRACE regalloc2::ion::dump                    > vreg126:
 TRACE regalloc2::ion::dump                    > vreg127:
 TRACE regalloc2::ion::dump                    > vreg128:
 TRACE regalloc2::ion::dump                    > vreg129:
 TRACE regalloc2::ion::dump                    > vreg130:
 TRACE regalloc2::ion::dump                    > vreg131:
 TRACE regalloc2::ion::dump                    > vreg132:
 TRACE regalloc2::ion::dump                    > vreg133:
 TRACE regalloc2::ion::dump                    > vreg134:
 TRACE regalloc2::ion::dump                    > vreg135:
 TRACE regalloc2::ion::dump                    > vreg136:
 TRACE regalloc2::ion::dump                    > vreg137:
 TRACE regalloc2::ion::dump                    > vreg138:
 TRACE regalloc2::ion::dump                    > vreg139:
 TRACE regalloc2::ion::dump                    > vreg140:
 TRACE regalloc2::ion::dump                    > vreg141:
 TRACE regalloc2::ion::dump                    > vreg142:
 TRACE regalloc2::ion::dump                    > vreg143:
 TRACE regalloc2::ion::dump                    > vreg144:
 TRACE regalloc2::ion::dump                    > vreg145:
 TRACE regalloc2::ion::dump                    > vreg146:
 TRACE regalloc2::ion::dump                    > vreg147:
 TRACE regalloc2::ion::dump                    > vreg148:
 TRACE regalloc2::ion::dump                    > vreg149:
 TRACE regalloc2::ion::dump                    > vreg150:
 TRACE regalloc2::ion::dump                    > vreg151:
 TRACE regalloc2::ion::dump                    > vreg152:
 TRACE regalloc2::ion::dump                    > vreg153:
 TRACE regalloc2::ion::dump                    > vreg154:
 TRACE regalloc2::ion::dump                    > vreg155:
 TRACE regalloc2::ion::dump                    > vreg156:
 TRACE regalloc2::ion::dump                    > vreg157:
 TRACE regalloc2::ion::dump                    > vreg158:
 TRACE regalloc2::ion::dump                    > vreg159:
 TRACE regalloc2::ion::dump                    > vreg160:
 TRACE regalloc2::ion::dump                    > vreg161:
 TRACE regalloc2::ion::dump                    > vreg162:
 TRACE regalloc2::ion::dump                    > vreg163:
 TRACE regalloc2::ion::dump                    > vreg164:
 TRACE regalloc2::ion::dump                    > vreg165:
 TRACE regalloc2::ion::dump                    > vreg166:
 TRACE regalloc2::ion::dump                    > vreg167:
 TRACE regalloc2::ion::dump                    > vreg168:
 TRACE regalloc2::ion::dump                    > vreg169:
 TRACE regalloc2::ion::dump                    > vreg170:
 TRACE regalloc2::ion::dump                    > vreg171:
 TRACE regalloc2::ion::dump                    > vreg172:
 TRACE regalloc2::ion::dump                    > vreg173:
 TRACE regalloc2::ion::dump                    > vreg174:
 TRACE regalloc2::ion::dump                    > vreg175:
 TRACE regalloc2::ion::dump                    > vreg176:
 TRACE regalloc2::ion::dump                    > vreg177:
 TRACE regalloc2::ion::dump                    > vreg178:
 TRACE regalloc2::ion::dump                    > vreg179:
 TRACE regalloc2::ion::dump                    > vreg180:
 TRACE regalloc2::ion::dump                    > vreg181:
 TRACE regalloc2::ion::dump                    > vreg182:
 TRACE regalloc2::ion::dump                    > vreg183:
 TRACE regalloc2::ion::dump                    > vreg184:
 TRACE regalloc2::ion::dump                    > vreg185:
 TRACE regalloc2::ion::dump                    > vreg186:
 TRACE regalloc2::ion::dump                    > vreg187:
 TRACE regalloc2::ion::dump                    > vreg188:
 TRACE regalloc2::ion::dump                    > vreg189:
 TRACE regalloc2::ion::dump                    > vreg190:
 TRACE regalloc2::ion::dump                    > vreg191:
 TRACE regalloc2::ion::dump                    > vreg192:
 TRACE regalloc2::ion::dump                    > vreg193:
 TRACE regalloc2::ion::dump                    >  * range progpoint0-post -- progpoint1-post: range0
 TRACE regalloc2::ion::dump                    > Ranges:
 TRACE regalloc2::ion::dump                    > range0: range=CodeRange { from: progpoint0-post, to: progpoint1-post } vreg=VRegIndex(193) bundle=LiveBundleIndex(0) weight=SpillWeight(8000.0)
 TRACE regalloc2::ion::dump                    >  * use at progpoint0-post (slot 0): Def: v193i reg
 TRACE regalloc2::ion::dump                    >  * use at progpoint1-pre (slot 0): Use: v193i fixed(p0i)
 TRACE regalloc2::ion::process                 > process_bundle: bundle LiveBundleIndex(0) hint PReg(hw = 63, class = Int, index = 63)
 TRACE regalloc2::ion::requirement             > compute_requirement: LiveBundleIndex(0)
 TRACE regalloc2::ion::requirement             >  -> LR LiveRangeIndex(0): CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::requirement             >   -> use Use { operand: Def: v193i reg, pos: progpoint0-post, slot: 0, weight: 35640 }
 TRACE regalloc2::ion::requirement             >      -> req Register
 TRACE regalloc2::ion::requirement             >   -> use Use { operand: Use: v193i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 }
 TRACE regalloc2::ion::requirement             >      -> req FixedReg(PReg(hw = 0, class = Int, index = 0))
 TRACE regalloc2::ion::requirement             >  -> final: FixedReg(PReg(hw = 0, class = Int, index = 0))
 TRACE regalloc2::ion::process                 > attempt 1, req FixedReg(PReg(hw = 0, class = Int, index = 0))
 TRACE regalloc2::ion::process                 > trying preg PRegIndex(0)
 TRACE regalloc2::ion::process                 > try_to_allocate_bundle_to_reg: LiveBundleIndex(0) -> PRegIndex(0)
 TRACE regalloc2::ion::process                 > alloc map for PRegIndex(0) in range LiveRangeKey { from: 1, to: 1 }..: {}
 TRACE regalloc2::ion::process                 >  -> range LR LiveRangeIndex(0): CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::process                 >   -> PReg range None
 TRACE regalloc2::ion::process                 >  -> no more PReg allocations; so no conflict possible!
 TRACE regalloc2::ion::process                 >   -> bundle LiveBundleIndex(0) assigned to preg PReg(hw = 0, class = Int, index = 0)
 TRACE regalloc2::ion::process                 >  -> allocated to any PRegIndex(0)
 TRACE regalloc2::ion::spill                   > allocating regs for spilled bundles
 TRACE regalloc2::ion::spill                   > allocate spillslot: 0
 TRACE regalloc2::ion::spill                   > spillslot allocator done
 TRACE regalloc2::ion::moves                   > apply_allocations_and_insert_moves
 TRACE regalloc2::ion::moves                   > blockparam_ins: []
 TRACE regalloc2::ion::moves                   > blockparam_outs: []
 TRACE regalloc2::ion::moves                   > get_alloc_for_range: LiveRangeIndex(0)
 TRACE regalloc2::ion::moves                   >  -> bundle: LiveBundleIndex(0)
 TRACE regalloc2::ion::moves                   >  -> allocation p0i
 TRACE regalloc2::ion::moves                   > apply_allocations: vreg VRegIndex(193) LR LiveRangeIndex(0) with range CodeRange { from: progpoint0-post, to: progpoint1-post } has alloc p0i
 TRACE regalloc2::ion::moves                   > applying to use: Use { operand: Def: v193i reg, pos: progpoint0-post, slot: 0, weight: 35640 }
 TRACE regalloc2::ion::moves                   > applying to use: Use { operand: Use: v193i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 }
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Register allocation: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode emission, (during Compilation passes)
 TRACE cranelift_codegen::machinst::buffer     > MachBuffer: first 1 labels are for blocks
 TRACE cranelift_codegen::machinst::vcode      > emitting block Block(0)
 TRACE cranelift_codegen::machinst::vcode      >  -> entry block
 TRACE cranelift_codegen::machinst::buffer     > MachBuffer: bind label MachLabel(0) at offset 4
 TRACE cranelift_codegen::machinst::buffer     > enter optimize_branches:
 b = []
 l = [MachLabel(0)]
 f = []
 TRACE cranelift_codegen::machinst::buffer     > leave optimize_branches:
 b = []
 l = [MachLabel(0)]
 f = []
 TRACE cranelift_codegen::machinst::abi        > Epilogue: [movq    %rbp, %rsp, popq    %rbp, ret]
 TRACE cranelift_codegen::machinst::buffer     > enter optimize_branches:
 b = []
 l = []
 f = []
 TRACE cranelift_codegen::machinst::buffer     > leave optimize_branches:
 b = []
 l = []
 f = []
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode emission finalization, (during VCode emission)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode emission finalization: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode emission: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Compilation passes: 1ms
 INFO  cranelift_jit::backend                  > defining function funcid21: function u0:21(i64, i64) system_v {
    sig0 = () -> i64 system_v

block0(v0: i64, v1: i64):
    v2 = call_indirect sig0, v0()
    store notrap aligned v2, v1
    return
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Compilation passes, (during <no pass>)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::context              > Number of CLIF instructions to optimize: 3
 DEBUG cranelift_codegen::context              > Number of CLIF blocks to optimize: 1
 TRACE cranelift_codegen::context              > Optimizing (opt level Speed):
function u0:21(i64, i64) system_v {
    sig0 = () -> i64 system_v

block0(v0: i64, v1: i64):
    v2 = call_indirect sig0, v0()
    store notrap aligned v2, v1
    return
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 TRACE cranelift_codegen::legalizer            > Pre-legalization function:
function u0:21(i64, i64) system_v {
    sig0 = () -> i64 system_v

block0(v0: i64, v1: i64):
    v2 = call_indirect sig0, v0()
    store notrap aligned v2, v1
    return
}

 TRACE cranelift_codegen::legalizer            > Post-legalization function:
function u0:21(i64, i64) system_v {
    sig0 = () -> i64 system_v

block0(v0: i64, v1: i64):
    v2 = call_indirect sig0, v0()
    store notrap aligned v2, v1
    return
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Remove unreachable blocks, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove unreachable blocks: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dead code elimination, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dead code elimination: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Remove constant phi-nodes, (during Compilation passes)
 DEBUG cranelift_codegen::remove_constant_phis > do_remove_constant_phis: done, 1 iters.   0 formals, of which 0 const.
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove constant phi-nodes: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Egraph based optimizations, (during Compilation passes)
 TRACE cranelift_codegen::context              > About to optimize with egraph phase:
function u0:21(i64, i64) system_v {
    sig0 = () -> i64 system_v

block0(v0: i64, v1: i64):
    v2 = call_indirect sig0, v0()
    store notrap aligned v2, v1
    return
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Loop analysis, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Loop analysis: 0ms
 TRACE cranelift_codegen::alias_analysis       > alias analysis: input is:
function u0:21(i64, i64) system_v {
    sig0 = () -> i64 system_v

block0(v0: i64, v1: i64):
    v2 = call_indirect sig0, v0()
    store notrap aligned v2, v1
    return
}

 TRACE cranelift_codegen::alias_analysis       > alias analysis: input to block0 is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst0: state is LastStores { heap: Some(inst0), table: Some(inst0), vmctx: Some(inst0), other: Some(inst0) }
 TRACE cranelift_codegen::alias_analysis       > after inst1: state is LastStores { heap: Some(inst0), table: Some(inst0), vmctx: Some(inst0), other: Some(inst1) }
 TRACE cranelift_codegen::alias_analysis       > after inst2: state is LastStores { heap: Some(inst0), table: Some(inst0), vmctx: Some(inst0), other: Some(inst1) }
 TRACE cranelift_codegen::egraph               > Processing block block0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for blockparam v0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for blockparam v1
 TRACE cranelift_codegen::egraph               > Processing inst inst0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v2
 TRACE cranelift_codegen::egraph               > rewriting arg v0 of inst inst0 to v0
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst0 with state LastStores { heap: None, table: None, vmctx: None, other: None } (CallIndirect { opcode: CallIndirect, args: EntityList { index: 5, unused: PhantomData<cranelift_codegen::ir::entities::Value> }, sig_ref: sig0 })
 TRACE cranelift_codegen::egraph               > Processing inst inst1
 TRACE cranelift_codegen::egraph               > rewriting arg v2 of inst inst1 to v2
 TRACE cranelift_codegen::egraph               > rewriting arg v1 of inst inst1 to v1
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst1 with state LastStores { heap: Some(inst0), table: Some(inst0), vmctx: Some(inst0), other: Some(inst0) } (Store { opcode: Store, args: [v2, v1], flags: MemFlags { bits: 1921 }, offset: Offset32(0) })
 TRACE cranelift_codegen::alias_analysis       > alias analysis: at inst1: store with data v2 at loc MemoryLoc { last_store: Some(inst1), address: v1, offset: Offset32(0), ty: types::I64, extending_opcode: None }
 TRACE cranelift_codegen::egraph               > Processing inst inst2
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst2 with state LastStores { heap: Some(inst0), table: Some(inst0), vmctx: Some(inst0), other: Some(inst1) } (MultiAry { opcode: Return, args: EntityList { index: 0, unused: PhantomData<cranelift_codegen::ir::entities::Value> } })
 TRACE cranelift_codegen::egraph               > egraph built:
function u0:21(i64, i64) system_v {
    sig0 = () -> i64 system_v

block0(v0: i64, v1: i64):
    v2 = call_indirect sig0, v0()
    store notrap aligned v2, v1
    return
}


 TRACE cranelift_codegen::egraph               >  -> v0 = Param(block0, 0)
 TRACE cranelift_codegen::egraph               >  -> v1 = Param(block0, 1)
 TRACE cranelift_codegen::egraph               >  -> v2 = Result(inst0, 0)
 TRACE cranelift_codegen::egraph               >   -> inst0 = CallIndirect { opcode: CallIndirect, args: EntityList { index: 5, unused: PhantomData<cranelift_codegen::ir::entities::Value> }, sig_ref: sig0 }
 TRACE cranelift_codegen::egraph               > stats: Stats {
    pure_inst: 0,
    pure_inst_deduped: 0,
    skeleton_inst: 3,
    alias_analysis_removed: 0,
    new_inst: 0,
    union: 0,
    subsume: 0,
    remat: 0,
    rewrite_rule_invoked: 0,
    rewrite_depth_limit: 0,
    elaborate_visit_node: 0,
    elaborate_memoize_hit: 0,
    elaborate_memoize_miss: 0,
    elaborate_remat: 0,
    elaborate_licm_hoist: 0,
    elaborate_func: 0,
    elaborate_func_pre_insts: 0,
    elaborate_func_post_insts: 0,
    elaborate_best_cost_fixpoint_iters: 0,
}
 TRACE cranelift_codegen::egraph               > pinned_union_count: 0
 TRACE cranelift_codegen::egraph::elaborate    > Entering fixpoint loop to compute the best values for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 0
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v0 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 1)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 1
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v0 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 1)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > finished fixpoint loop to compute best value for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v0: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v0)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v1: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v1)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v2: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v2)
 DEBUG cranelift_codegen::context              > egraph stats: Stats { pure_inst: 0, pure_inst_deduped: 0, skeleton_inst: 3, alias_analysis_removed: 0, new_inst: 0, union: 0, subsume: 0, remat: 0, rewrite_rule_invoked: 0, rewrite_depth_limit: 0, elaborate_visit_node: 0, elaborate_memoize_hit: 0, elaborate_memoize_miss: 0, elaborate_remat: 0, elaborate_licm_hoist: 0, elaborate_func: 1, elaborate_func_pre_insts: 3, elaborate_func_post_insts: 3, elaborate_best_cost_fixpoint_iters: 2 }
 TRACE cranelift_codegen::context              > pinned_union_count: 0
 TRACE cranelift_codegen::context              > After egraph optimization:
function u0:21(i64, i64) system_v {
    sig0 = () -> i64 system_v

block0(v0: i64, v1: i64):
    return
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Egraph based optimizations: 0ms
 TRACE cranelift_codegen::machinst::abi        > ABISig: sig Signature { params: [AbiParam { value_type: types::I64, purpose: Normal, extension: None }, AbiParam { value_type: types::I64, purpose: Normal, extension: None }], returns: [], call_conv: SystemV } => args end = 2 rets end = 0
             arg stack = 0 ret stack = 0 stack_ret_arg = false
 TRACE cranelift_codegen::machinst::abi        > ABISig: sig Signature { params: [], returns: [AbiParam { value_type: types::I64, purpose: Normal, extension: None }], call_conv: SystemV } => args end = 3 rets end = 3
             arg stack = 0 ret stack = 0 stack_ret_arg = false
 TRACE cranelift_codegen::machinst::abi        > ABI: func signature Signature { params: [AbiParam { value_type: types::I64, purpose: Normal, extension: None }, AbiParam { value_type: types::I64, purpose: Normal, extension: None }], returns: [], call_conv: SystemV }
 TRACE cranelift_codegen::machinst::blockorder > BlockLoweringOrder: function body function u0:21(i64, i64) system_v {
    sig0 = () -> i64 system_v

block0(v0: i64, v1: i64):
    return
}

 TRACE cranelift_codegen::machinst::blockorder > BlockLoweringOrder: BlockLoweringOrder {
    lowered_order: [
        Orig {
            block: block0,
        },
    ],
    lowered_succ_indices: [],
    lowered_succ_ranges: [
        (
            None,
            0..0,
        ),
    ],
    cold_blocks: {},
    indirect_branch_targets: {},
}
 TRACE cranelift_codegen::machinst::lower      > bb block0 param v0: regs ValueRegs { parts: [v192, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > bb block0 param v1: regs ValueRegs { parts: [v193, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > bb block0 inst inst2 has color 1
 TRACE cranelift_codegen::machinst::lower      >  -> side-effecting; incrementing color for next inst
 DEBUG cranelift_codegen::machinst::compile    > Number of CLIF instructions to lower: 3
 DEBUG cranelift_codegen::machinst::compile    > Number of CLIF blocks to lower: 1
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode lowering, (during Compilation passes)
 TRACE cranelift_codegen::machinst::lower      > about to lower function: function u0:21(i64, i64) system_v {
    sig0 = () -> i64 system_v

block0(v0: i64, v1: i64):
    return
}

 TRACE cranelift_codegen::machinst::lower      > lower_clif_block: block block0 inst inst2 (MultiAry { opcode: Return, args: EntityList { index: 0, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }) is_branch false side_effect true value_needed false
 TRACE cranelift_codegen::machinst::lower      > lowering: inst inst2: MultiAry { opcode: Return, args: EntityList { index: 0, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }
 TRACE cranelift_codegen::machinst::lower      > emit: rets
 TRACE cranelift_codegen::machinst::lower      > gen_arg_setup: entry BB block0 args are:
[v0, v1]
 TRACE cranelift_codegen::machinst::abi        > gen_retval_area_setup: not needed
 TRACE cranelift_codegen::machinst::lower      > built vcode:
VRegAllocator {
}
Backwards VCode {
  Entry block: 0
Block 0:
    (original IR block: block0)
  Inst 0: rets
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode lowering: 0ms
 DEBUG cranelift_codegen::machinst::compile    > Number of lowered vcode instructions: 1
 DEBUG cranelift_codegen::machinst::compile    > Number of lowered vcode blocks: 1
 TRACE cranelift_codegen::machinst::compile    > vcode from lowering: 
VCode {
  Entry block: 0
Block 0:
    (original IR block: block0)
  Inst 0: rets
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Register allocation, (during Compilation passes)
 TRACE regalloc2::ion::liveranges              > computing liveins for block0
 TRACE regalloc2::ion::liveranges              >  -> initial liveout set: []
 TRACE regalloc2::ion::liveranges              > computed liveins at block0: []
 TRACE regalloc2::ion::merge                   > merge_vreg_bundles: creating vreg bundles
 TRACE regalloc2::ion::merge                   > done merging bundles
 TRACE regalloc2::ion::dump                    > Bundles:
 TRACE regalloc2::ion::dump                    > VRegs:
 TRACE regalloc2::ion::dump                    > vreg0:
 TRACE regalloc2::ion::dump                    > vreg1:
 TRACE regalloc2::ion::dump                    > vreg2:
 TRACE regalloc2::ion::dump                    > vreg3:
 TRACE regalloc2::ion::dump                    > vreg4:
 TRACE regalloc2::ion::dump                    > vreg5:
 TRACE regalloc2::ion::dump                    > vreg6:
 TRACE regalloc2::ion::dump                    > vreg7:
 TRACE regalloc2::ion::dump                    > vreg8:
 TRACE regalloc2::ion::dump                    > vreg9:
 TRACE regalloc2::ion::dump                    > vreg10:
 TRACE regalloc2::ion::dump                    > vreg11:
 TRACE regalloc2::ion::dump                    > vreg12:
 TRACE regalloc2::ion::dump                    > vreg13:
 TRACE regalloc2::ion::dump                    > vreg14:
 TRACE regalloc2::ion::dump                    > vreg15:
 TRACE regalloc2::ion::dump                    > vreg16:
 TRACE regalloc2::ion::dump                    > vreg17:
 TRACE regalloc2::ion::dump                    > vreg18:
 TRACE regalloc2::ion::dump                    > vreg19:
 TRACE regalloc2::ion::dump                    > vreg20:
 TRACE regalloc2::ion::dump                    > vreg21:
 TRACE regalloc2::ion::dump                    > vreg22:
 TRACE regalloc2::ion::dump                    > vreg23:
 TRACE regalloc2::ion::dump                    > vreg24:
 TRACE regalloc2::ion::dump                    > vreg25:
 TRACE regalloc2::ion::dump                    > vreg26:
 TRACE regalloc2::ion::dump                    > vreg27:
 TRACE regalloc2::ion::dump                    > vreg28:
 TRACE regalloc2::ion::dump                    > vreg29:
 TRACE regalloc2::ion::dump                    > vreg30:
 TRACE regalloc2::ion::dump                    > vreg31:
 TRACE regalloc2::ion::dump                    > vreg32:
 TRACE regalloc2::ion::dump                    > vreg33:
 TRACE regalloc2::ion::dump                    > vreg34:
 TRACE regalloc2::ion::dump                    > vreg35:
 TRACE regalloc2::ion::dump                    > vreg36:
 TRACE regalloc2::ion::dump                    > vreg37:
 TRACE regalloc2::ion::dump                    > vreg38:
 TRACE regalloc2::ion::dump                    > vreg39:
 TRACE regalloc2::ion::dump                    > vreg40:
 TRACE regalloc2::ion::dump                    > vreg41:
 TRACE regalloc2::ion::dump                    > vreg42:
 TRACE regalloc2::ion::dump                    > vreg43:
 TRACE regalloc2::ion::dump                    > vreg44:
 TRACE regalloc2::ion::dump                    > vreg45:
 TRACE regalloc2::ion::dump                    > vreg46:
 TRACE regalloc2::ion::dump                    > vreg47:
 TRACE regalloc2::ion::dump                    > vreg48:
 TRACE regalloc2::ion::dump                    > vreg49:
 TRACE regalloc2::ion::dump                    > vreg50:
 TRACE regalloc2::ion::dump                    > vreg51:
 TRACE regalloc2::ion::dump                    > vreg52:
 TRACE regalloc2::ion::dump                    > vreg53:
 TRACE regalloc2::ion::dump                    > vreg54:
 TRACE regalloc2::ion::dump                    > vreg55:
 TRACE regalloc2::ion::dump                    > vreg56:
 TRACE regalloc2::ion::dump                    > vreg57:
 TRACE regalloc2::ion::dump                    > vreg58:
 TRACE regalloc2::ion::dump                    > vreg59:
 TRACE regalloc2::ion::dump                    > vreg60:
 TRACE regalloc2::ion::dump                    > vreg61:
 TRACE regalloc2::ion::dump                    > vreg62:
 TRACE regalloc2::ion::dump                    > vreg63:
 TRACE regalloc2::ion::dump                    > vreg64:
 TRACE regalloc2::ion::dump                    > vreg65:
 TRACE regalloc2::ion::dump                    > vreg66:
 TRACE regalloc2::ion::dump                    > vreg67:
 TRACE regalloc2::ion::dump                    > vreg68:
 TRACE regalloc2::ion::dump                    > vreg69:
 TRACE regalloc2::ion::dump                    > vreg70:
 TRACE regalloc2::ion::dump                    > vreg71:
 TRACE regalloc2::ion::dump                    > vreg72:
 TRACE regalloc2::ion::dump                    > vreg73:
 TRACE regalloc2::ion::dump                    > vreg74:
 TRACE regalloc2::ion::dump                    > vreg75:
 TRACE regalloc2::ion::dump                    > vreg76:
 TRACE regalloc2::ion::dump                    > vreg77:
 TRACE regalloc2::ion::dump                    > vreg78:
 TRACE regalloc2::ion::dump                    > vreg79:
 TRACE regalloc2::ion::dump                    > vreg80:
 TRACE regalloc2::ion::dump                    > vreg81:
 TRACE regalloc2::ion::dump                    > vreg82:
 TRACE regalloc2::ion::dump                    > vreg83:
 TRACE regalloc2::ion::dump                    > vreg84:
 TRACE regalloc2::ion::dump                    > vreg85:
 TRACE regalloc2::ion::dump                    > vreg86:
 TRACE regalloc2::ion::dump                    > vreg87:
 TRACE regalloc2::ion::dump                    > vreg88:
 TRACE regalloc2::ion::dump                    > vreg89:
 TRACE regalloc2::ion::dump                    > vreg90:
 TRACE regalloc2::ion::dump                    > vreg91:
 TRACE regalloc2::ion::dump                    > vreg92:
 TRACE regalloc2::ion::dump                    > vreg93:
 TRACE regalloc2::ion::dump                    > vreg94:
 TRACE regalloc2::ion::dump                    > vreg95:
 TRACE regalloc2::ion::dump                    > vreg96:
 TRACE regalloc2::ion::dump                    > vreg97:
 TRACE regalloc2::ion::dump                    > vreg98:
 TRACE regalloc2::ion::dump                    > vreg99:
 TRACE regalloc2::ion::dump                    > vreg100:
 TRACE regalloc2::ion::dump                    > vreg101:
 TRACE regalloc2::ion::dump                    > vreg102:
 TRACE regalloc2::ion::dump                    > vreg103:
 TRACE regalloc2::ion::dump                    > vreg104:
 TRACE regalloc2::ion::dump                    > vreg105:
 TRACE regalloc2::ion::dump                    > vreg106:
 TRACE regalloc2::ion::dump                    > vreg107:
 TRACE regalloc2::ion::dump                    > vreg108:
 TRACE regalloc2::ion::dump                    > vreg109:
 TRACE regalloc2::ion::dump                    > vreg110:
 TRACE regalloc2::ion::dump                    > vreg111:
 TRACE regalloc2::ion::dump                    > vreg112:
 TRACE regalloc2::ion::dump                    > vreg113:
 TRACE regalloc2::ion::dump                    > vreg114:
 TRACE regalloc2::ion::dump                    > vreg115:
 TRACE regalloc2::ion::dump                    > vreg116:
 TRACE regalloc2::ion::dump                    > vreg117:
 TRACE regalloc2::ion::dump                    > vreg118:
 TRACE regalloc2::ion::dump                    > vreg119:
 TRACE regalloc2::ion::dump                    > vreg120:
 TRACE regalloc2::ion::dump                    > vreg121:
 TRACE regalloc2::ion::dump                    > vreg122:
 TRACE regalloc2::ion::dump                    > vreg123:
 TRACE regalloc2::ion::dump                    > vreg124:
 TRACE regalloc2::ion::dump                    > vreg125:
 TRACE regalloc2::ion::dump                    > vreg126:
 TRACE regalloc2::ion::dump                    > vreg127:
 TRACE regalloc2::ion::dump                    > vreg128:
 TRACE regalloc2::ion::dump                    > vreg129:
 TRACE regalloc2::ion::dump                    > vreg130:
 TRACE regalloc2::ion::dump                    > vreg131:
 TRACE regalloc2::ion::dump                    > vreg132:
 TRACE regalloc2::ion::dump                    > vreg133:
 TRACE regalloc2::ion::dump                    > vreg134:
 TRACE regalloc2::ion::dump                    > vreg135:
 TRACE regalloc2::ion::dump                    > vreg136:
 TRACE regalloc2::ion::dump                    > vreg137:
 TRACE regalloc2::ion::dump                    > vreg138:
 TRACE regalloc2::ion::dump                    > vreg139:
 TRACE regalloc2::ion::dump                    > vreg140:
 TRACE regalloc2::ion::dump                    > vreg141:
 TRACE regalloc2::ion::dump                    > vreg142:
 TRACE regalloc2::ion::dump                    > vreg143:
 TRACE regalloc2::ion::dump                    > vreg144:
 TRACE regalloc2::ion::dump                    > vreg145:
 TRACE regalloc2::ion::dump                    > vreg146:
 TRACE regalloc2::ion::dump                    > vreg147:
 TRACE regalloc2::ion::dump                    > vreg148:
 TRACE regalloc2::ion::dump                    > vreg149:
 TRACE regalloc2::ion::dump                    > vreg150:
 TRACE regalloc2::ion::dump                    > vreg151:
 TRACE regalloc2::ion::dump                    > vreg152:
 TRACE regalloc2::ion::dump                    > vreg153:
 TRACE regalloc2::ion::dump                    > vreg154:
 TRACE regalloc2::ion::dump                    > vreg155:
 TRACE regalloc2::ion::dump                    > vreg156:
 TRACE regalloc2::ion::dump                    > vreg157:
 TRACE regalloc2::ion::dump                    > vreg158:
 TRACE regalloc2::ion::dump                    > vreg159:
 TRACE regalloc2::ion::dump                    > vreg160:
 TRACE regalloc2::ion::dump                    > vreg161:
 TRACE regalloc2::ion::dump                    > vreg162:
 TRACE regalloc2::ion::dump                    > vreg163:
 TRACE regalloc2::ion::dump                    > vreg164:
 TRACE regalloc2::ion::dump                    > vreg165:
 TRACE regalloc2::ion::dump                    > vreg166:
 TRACE regalloc2::ion::dump                    > vreg167:
 TRACE regalloc2::ion::dump                    > vreg168:
 TRACE regalloc2::ion::dump                    > vreg169:
 TRACE regalloc2::ion::dump                    > vreg170:
 TRACE regalloc2::ion::dump                    > vreg171:
 TRACE regalloc2::ion::dump                    > vreg172:
 TRACE regalloc2::ion::dump                    > vreg173:
 TRACE regalloc2::ion::dump                    > vreg174:
 TRACE regalloc2::ion::dump                    > vreg175:
 TRACE regalloc2::ion::dump                    > vreg176:
 TRACE regalloc2::ion::dump                    > vreg177:
 TRACE regalloc2::ion::dump                    > vreg178:
 TRACE regalloc2::ion::dump                    > vreg179:
 TRACE regalloc2::ion::dump                    > vreg180:
 TRACE regalloc2::ion::dump                    > vreg181:
 TRACE regalloc2::ion::dump                    > vreg182:
 TRACE regalloc2::ion::dump                    > vreg183:
 TRACE regalloc2::ion::dump                    > vreg184:
 TRACE regalloc2::ion::dump                    > vreg185:
 TRACE regalloc2::ion::dump                    > vreg186:
 TRACE regalloc2::ion::dump                    > vreg187:
 TRACE regalloc2::ion::dump                    > vreg188:
 TRACE regalloc2::ion::dump                    > vreg189:
 TRACE regalloc2::ion::dump                    > vreg190:
 TRACE regalloc2::ion::dump                    > vreg191:
 TRACE regalloc2::ion::dump                    > vreg192:
 TRACE regalloc2::ion::dump                    > vreg193:
 TRACE regalloc2::ion::dump                    > Ranges:
 TRACE regalloc2::ion::spill                   > allocating regs for spilled bundles
 TRACE regalloc2::ion::spill                   > spillslot allocator done
 TRACE regalloc2::ion::moves                   > apply_allocations_and_insert_moves
 TRACE regalloc2::ion::moves                   > blockparam_ins: []
 TRACE regalloc2::ion::moves                   > blockparam_outs: []
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Register allocation: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode emission, (during Compilation passes)
 TRACE cranelift_codegen::machinst::buffer     > MachBuffer: first 1 labels are for blocks
 TRACE cranelift_codegen::machinst::vcode      > emitting block Block(0)
 TRACE cranelift_codegen::machinst::vcode      >  -> entry block
 TRACE cranelift_codegen::machinst::buffer     > MachBuffer: bind label MachLabel(0) at offset 4
 TRACE cranelift_codegen::machinst::buffer     > enter optimize_branches:
 b = []
 l = [MachLabel(0)]
 f = []
 TRACE cranelift_codegen::machinst::buffer     > leave optimize_branches:
 b = []
 l = [MachLabel(0)]
 f = []
 TRACE cranelift_codegen::machinst::abi        > Epilogue: [movq    %rbp, %rsp, popq    %rbp, ret]
 TRACE cranelift_codegen::machinst::buffer     > enter optimize_branches:
 b = []
 l = []
 f = []
 TRACE cranelift_codegen::machinst::buffer     > leave optimize_branches:
 b = []
 l = []
 f = []
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode emission finalization, (during VCode emission)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode emission finalization: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode emission: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Compilation passes: 1ms
 INFO  cranelift_jit::backend                  > defining function funcid1: function u0:1(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp slt v2, v3  ; v3 = 0
    return v4
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Compilation passes, (during <no pass>)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::context              > Number of CLIF instructions to optimize: 4
 DEBUG cranelift_codegen::context              > Number of CLIF blocks to optimize: 1
 TRACE cranelift_codegen::context              > Optimizing (opt level Speed):
function u0:1(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp slt v2, v3  ; v3 = 0
    return v4
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 TRACE cranelift_codegen::legalizer            > Pre-legalization function:
function u0:1(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp slt v2, v3  ; v3 = 0
    return v4
}

 TRACE cranelift_codegen::legalizer            > Post-legalization function:
function u0:1(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp slt v2, v3  ; v3 = 0
    return v4
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Remove unreachable blocks, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove unreachable blocks: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dead code elimination, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dead code elimination: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Remove constant phi-nodes, (during Compilation passes)
 DEBUG cranelift_codegen::remove_constant_phis > do_remove_constant_phis: done, 1 iters.   0 formals, of which 0 const.
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove constant phi-nodes: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Egraph based optimizations, (during Compilation passes)
 TRACE cranelift_codegen::context              > About to optimize with egraph phase:
function u0:1(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp slt v2, v3  ; v3 = 0
    return v4
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Loop analysis, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Loop analysis: 0ms
 TRACE cranelift_codegen::alias_analysis       > alias analysis: input is:
function u0:1(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp slt v2, v3  ; v3 = 0
    return v4
}

 TRACE cranelift_codegen::alias_analysis       > alias analysis: input to block0 is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst0: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst1: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst2: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst3: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::egraph               > Processing block block0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for blockparam v1
 TRACE cranelift_codegen::egraph               > Processing inst inst0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v2
 TRACE cranelift_codegen::egraph               > rewriting arg v1 of inst inst0 to v1
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v2
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > iter: value v1
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v2 -> [v2]
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst1
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v3
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v3
 TRACE cranelift_codegen::opts                 > iter: value v3
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > remat: v3
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v3 -> [v3, v3]
 TRACE cranelift_codegen::egraph               > Returned from ISLE for v3, got v3
 TRACE cranelift_codegen::egraph               >  -> same as orig value; skipping
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst2
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v4
 TRACE cranelift_codegen::egraph               > rewriting arg v2 of inst inst2 to v2
 TRACE cranelift_codegen::egraph               > rewriting arg v3 of inst inst2 to v3
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v4
 TRACE cranelift_codegen::opts                 > iter: value v4
 TRACE cranelift_codegen::opts                 >  -> value of type i8
 TRACE cranelift_codegen::opts                 > iter: value v3
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 2
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v5
 TRACE cranelift_codegen::opts                 > iter: value v5
 TRACE cranelift_codegen::opts                 >  -> value of type i8
 TRACE cranelift_codegen::opts                 > remat: v5
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v5 -> [v5, v5]
 TRACE cranelift_codegen::egraph               > Returned from ISLE for v5, got v5
 TRACE cranelift_codegen::egraph               >  -> same as orig value; skipping
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 1
 TRACE cranelift_codegen::opts                 > make_inst_ctor: UnaryImm { opcode: Iconst, imm: Imm64(0) } -> v5
 TRACE cranelift_codegen::opts                 > subsume: v5
 TRACE cranelift_codegen::opts                 > iter: value v3
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v4 -> [v5, v4]
 TRACE cranelift_codegen::egraph               > Returned from ISLE for v4, got v5
 TRACE cranelift_codegen::unionfind            > union: v5, v4
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst3
 TRACE cranelift_codegen::egraph               > rewriting arg v4 of inst inst3 to v5
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst3 with state LastStores { heap: None, table: None, vmctx: None, other: None } (MultiAry { opcode: Return, args: EntityList { index: 17, unused: PhantomData<cranelift_codegen::ir::entities::Value> } })
 TRACE cranelift_codegen::egraph               > egraph built:
function u0:1(i32) -> i8 system_v {
block0(v1: i32):
    return v5  ; v5 = 0
}


 TRACE cranelift_codegen::egraph               >  -> v1 = Param(block0, 0)
 TRACE cranelift_codegen::egraph               >  -> v2 = Result(inst0, 0)
 TRACE cranelift_codegen::egraph               >   -> inst0 = Unary { opcode: Uextend, arg: v1 }
 TRACE cranelift_codegen::egraph               >  -> v3 = Result(inst1, 0)
 TRACE cranelift_codegen::egraph               >   -> inst1 = UnaryImm { opcode: Iconst, imm: Imm64(0) }
 TRACE cranelift_codegen::egraph               >  -> v4 = Result(inst2, 0)
 TRACE cranelift_codegen::egraph               >   -> inst2 = IntCompare { opcode: Icmp, args: [v2, v3], cond: SignedLessThan }
 TRACE cranelift_codegen::egraph               >  -> v5 = Result(inst4, 0)
 TRACE cranelift_codegen::egraph               >   -> inst4 = UnaryImm { opcode: Iconst, imm: Imm64(0) }
 TRACE cranelift_codegen::egraph               > stats: Stats {
    pure_inst: 4,
    pure_inst_deduped: 0,
    skeleton_inst: 1,
    alias_analysis_removed: 0,
    new_inst: 1,
    union: 0,
    subsume: 1,
    remat: 2,
    rewrite_rule_invoked: 4,
    rewrite_depth_limit: 0,
    elaborate_visit_node: 0,
    elaborate_memoize_hit: 0,
    elaborate_memoize_miss: 0,
    elaborate_remat: 0,
    elaborate_licm_hoist: 0,
    elaborate_func: 0,
    elaborate_func_pre_insts: 0,
    elaborate_func_post_insts: 0,
    elaborate_best_cost_fixpoint_iters: 0,
}
 TRACE cranelift_codegen::egraph               > pinned_union_count: 0
 TRACE cranelift_codegen::egraph::elaborate    > Entering fixpoint loop to compute the best values for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 0
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v2 = Cost::Finite { op_cost: 2, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v3 def Result(inst1, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v3 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v4 def Result(inst2, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v4 = Cost::Finite { op_cost: 7, depth: 2 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v5 def Result(inst4, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v5 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 1
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v2 = Cost::Finite { op_cost: 2, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v3 def Result(inst1, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v3 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v4 def Result(inst2, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v4 = Cost::Finite { op_cost: 7, depth: 2 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v5 def Result(inst4, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v5 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > finished fixpoint loop to compute best value for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v1: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v1)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v2: BestEntry(Cost::Finite { op_cost: 2, depth: 1 }, v2)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v3: BestEntry(Cost::Finite { op_cost: 1, depth: 1 }, v3)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v4: BestEntry(Cost::Finite { op_cost: 7, depth: 2 }, v4)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v5: BestEntry(Cost::Finite { op_cost: 1, depth: 1 }, v5)
 TRACE cranelift_codegen::egraph::elaborate    > need inst inst4 before inst3
 TRACE cranelift_codegen::egraph::elaborate    >  -> no location; using original inst
 TRACE cranelift_codegen::egraph::elaborate    >  -> inserting identity mapping for v5
 TRACE cranelift_codegen::egraph::elaborate    >  -> Terminator elab arg v5 is best value is v5
 DEBUG cranelift_codegen::context              > egraph stats: Stats { pure_inst: 4, pure_inst_deduped: 0, skeleton_inst: 1, alias_analysis_removed: 0, new_inst: 1, union: 0, subsume: 1, remat: 2, rewrite_rule_invoked: 4, rewrite_depth_limit: 0, elaborate_visit_node: 0, elaborate_memoize_hit: 0, elaborate_memoize_miss: 0, elaborate_remat: 0, elaborate_licm_hoist: 0, elaborate_func: 1, elaborate_func_pre_insts: 5, elaborate_func_post_insts: 5, elaborate_best_cost_fixpoint_iters: 2 }
 TRACE cranelift_codegen::context              > pinned_union_count: 0
 TRACE cranelift_codegen::context              > After egraph optimization:
function u0:1(i32) -> i8 system_v {
block0(v1: i32):
    v5 = iconst.i8 0
    return v5  ; v5 = 0
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Egraph based optimizations: 0ms
 TRACE cranelift_codegen::machinst::abi        > ABISig: sig Signature { params: [AbiParam { value_type: types::I32, purpose: Normal, extension: None }], returns: [AbiParam { value_type: types::I8, purpose: Normal, extension: None }], call_conv: SystemV } => args end = 2 rets end = 1
             arg stack = 0 ret stack = 0 stack_ret_arg = false
 TRACE cranelift_codegen::machinst::abi        > ABI: func signature Signature { params: [AbiParam { value_type: types::I32, purpose: Normal, extension: None }], returns: [AbiParam { value_type: types::I8, purpose: Normal, extension: None }], call_conv: SystemV }
 TRACE cranelift_codegen::machinst::blockorder > BlockLoweringOrder: function body function u0:1(i32) -> i8 system_v {
block0(v1: i32):
    v5 = iconst.i8 0
    return v5  ; v5 = 0
}

 TRACE cranelift_codegen::machinst::blockorder > BlockLoweringOrder: BlockLoweringOrder {
    lowered_order: [
        Orig {
            block: block0,
        },
    ],
    lowered_succ_indices: [],
    lowered_succ_ranges: [
        (
            None,
            0..0,
        ),
    ],
    cold_blocks: {},
    indirect_branch_targets: {},
}
 TRACE cranelift_codegen::machinst::lower      > bb block0 param v1: regs ValueRegs { parts: [v192, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > bb block0 inst inst4 (UnaryImm { opcode: Iconst, imm: Imm64(0) }): result v5 regs ValueRegs { parts: [v193, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > bb block0 inst inst4 has color 1
 TRACE cranelift_codegen::machinst::lower      >  -> constant: 0
 TRACE cranelift_codegen::machinst::lower      > bb block0 inst inst3 has color 1
 TRACE cranelift_codegen::machinst::lower      >  -> side-effecting; incrementing color for next inst
 TRACE cranelift_codegen::machinst::lower      > arg v5 used, old state Unused, new Once
 DEBUG cranelift_codegen::machinst::compile    > Number of CLIF instructions to lower: 5
 DEBUG cranelift_codegen::machinst::compile    > Number of CLIF blocks to lower: 1
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode lowering, (during Compilation passes)
 TRACE cranelift_codegen::machinst::lower      > about to lower function: function u0:1(i32) -> i8 system_v {
block0(v1: i32):
    v5 = iconst.i8 0
    return v5  ; v5 = 0
}

 TRACE cranelift_codegen::machinst::lower      > lower_clif_block: block block0 inst inst3 (MultiAry { opcode: Return, args: EntityList { index: 17, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }) is_branch false side_effect true value_needed false
 TRACE cranelift_codegen::machinst::lower      > lowering: inst inst3: MultiAry { opcode: Return, args: EntityList { index: 17, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }
 TRACE cranelift_codegen::machinst::lower      > put_value_in_regs: val v5
 TRACE cranelift_codegen::machinst::lower      >  -> regs ValueRegs { parts: [v193, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > emit: rets %v193=%rax
 TRACE cranelift_codegen::machinst::lower      > lower_clif_block: block block0 inst inst4 (UnaryImm { opcode: Iconst, imm: Imm64(0) }) is_branch false side_effect false value_needed true
 TRACE cranelift_codegen::machinst::lower      > lowering: inst inst4: UnaryImm { opcode: Iconst, imm: Imm64(0) }
 TRACE cranelift_codegen::machinst::lower      > emit: xorl    %v194l, %v194l, %v194l
 TRACE cranelift_codegen::machinst::lower      > set vreg alias: v5 = v193, lowering = v194
 TRACE cranelift_codegen::machinst::lower      > gen_arg_setup: entry BB block0 args are:
[v1]
 TRACE cranelift_codegen::machinst::abi        > gen_retval_area_setup: not needed
 TRACE cranelift_codegen::machinst::lower      > built vcode:
VRegAllocator {
  v193 := v194
}
Backwards VCode {
  Entry block: 0
Block 0:
    (original IR block: block0)
  Inst 0: rets %v193=%rax
  Inst 1: xorl    %v194l, %v194l, %v194l
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode lowering: 0ms
 DEBUG cranelift_codegen::machinst::compile    > Number of lowered vcode instructions: 2
 DEBUG cranelift_codegen::machinst::compile    > Number of lowered vcode blocks: 1
 TRACE cranelift_codegen::machinst::compile    > vcode from lowering: 
VCode {
  Entry block: 0
Block 0:
    (original IR block: block0)
  Inst 0: xorl    %v194l, %v194l, %v194l
  Inst 1: rets %v194=%rax
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Register allocation, (during Compilation passes)
 TRACE regalloc2::ion::liveranges              > computing liveins for block0
 TRACE regalloc2::ion::liveranges              >  -> initial liveout set: []
 TRACE regalloc2::ion::liveranges              > op Use: v194i fixed(p0i) was_live = false
 TRACE regalloc2::ion::liveranges              > op Def: v194i reg was_live = true
 TRACE regalloc2::ion::liveranges              > computed liveins at block0: []
 TRACE regalloc2::ion::liveranges              > processing inst1 operand at progpoint1-pre: Use: v194i fixed(p0i)
 TRACE regalloc2::ion::liveranges              > add_liverange_to_vreg: vreg VRegIndex(194) range CodeRange { from: progpoint0-pre, to: progpoint1-post }
 TRACE regalloc2::ion::liveranges              > Use of Use: v194i fixed(p0i) at progpoint1-pre -> LiveRangeIndex(0)
 TRACE regalloc2::ion::liveranges              > insert use Use { operand: Use: v194i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 } into lr LiveRangeIndex(0) with weight SpillWeight(3000.0)
 TRACE regalloc2::ion::liveranges              >   -> now range has weight SpillWeight(3000.0)
 TRACE regalloc2::ion::liveranges              > processing inst0 operand at progpoint0-post: Def: v194i reg
 TRACE regalloc2::ion::liveranges              > Def of v194 at progpoint0-post
 TRACE regalloc2::ion::liveranges              >  -> has existing LR LiveRangeIndex(0)
 TRACE regalloc2::ion::liveranges              > insert use Use { operand: Def: v194i reg, pos: progpoint0-post, slot: 0, weight: 35640 } into lr LiveRangeIndex(0) with weight SpillWeight(5000.0)
 TRACE regalloc2::ion::liveranges              >   -> now range has weight SpillWeight(8000.0)
 TRACE regalloc2::ion::liveranges              >  -> started at block start; trimming to progpoint0-post
 TRACE regalloc2::ion::liveranges              > multi-fixed-reg cleanup: vreg VRegIndex(194) range LiveRangeIndex(0)
 TRACE regalloc2::ion::merge                   > merge_vreg_bundles: creating vreg bundles
 TRACE regalloc2::ion::merge                   > vreg v194 gets bundle0
 TRACE regalloc2::ion::merge                   >  -> with LR range0: CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::merge                   > done merging bundles
 TRACE regalloc2::ion::merge                   > enqueueing bundle0
 TRACE regalloc2::ion::merge                   >  -> prio 1
 TRACE regalloc2::ion::process                 > recompute bundle properties: bundle LiveBundleIndex(0)
 TRACE regalloc2::ion::process                 >   -> use: Use { operand: Def: v194i reg, pos: progpoint0-post, slot: 0, weight: 35640 }
 TRACE regalloc2::ion::process                 >   -> use: Use { operand: Use: v194i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 }
 TRACE regalloc2::ion::process                 >   -> fixed operand at progpoint1-pre: Use: v194i fixed(p0i)
 TRACE regalloc2::ion::process                 >   -> first range has range CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::process                 >   -> minimal: false
 TRACE regalloc2::ion::process                 >   -> uses spill weight: +SpillWeight(8000.0)
 TRACE regalloc2::ion::process                 >  -> dividing by prio 1; final weight 8000
 TRACE regalloc2::ion::dump                    > Bundles:
 TRACE regalloc2::ion::dump                    > bundle0: spillset=SpillSetIndex(0) alloc=none
 TRACE regalloc2::ion::dump                    >  * range progpoint0-post -- progpoint1-post: range0
 TRACE regalloc2::ion::dump                    > VRegs:
 TRACE regalloc2::ion::dump                    > vreg0:
 TRACE regalloc2::ion::dump                    > vreg1:
 TRACE regalloc2::ion::dump                    > vreg2:
 TRACE regalloc2::ion::dump                    > vreg3:
 TRACE regalloc2::ion::dump                    > vreg4:
 TRACE regalloc2::ion::dump                    > vreg5:
 TRACE regalloc2::ion::dump                    > vreg6:
 TRACE regalloc2::ion::dump                    > vreg7:
 TRACE regalloc2::ion::dump                    > vreg8:
 TRACE regalloc2::ion::dump                    > vreg9:
 TRACE regalloc2::ion::dump                    > vreg10:
 TRACE regalloc2::ion::dump                    > vreg11:
 TRACE regalloc2::ion::dump                    > vreg12:
 TRACE regalloc2::ion::dump                    > vreg13:
 TRACE regalloc2::ion::dump                    > vreg14:
 TRACE regalloc2::ion::dump                    > vreg15:
 TRACE regalloc2::ion::dump                    > vreg16:
 TRACE regalloc2::ion::dump                    > vreg17:
 TRACE regalloc2::ion::dump                    > vreg18:
 TRACE regalloc2::ion::dump                    > vreg19:
 TRACE regalloc2::ion::dump                    > vreg20:
 TRACE regalloc2::ion::dump                    > vreg21:
 TRACE regalloc2::ion::dump                    > vreg22:
 TRACE regalloc2::ion::dump                    > vreg23:
 TRACE regalloc2::ion::dump                    > vreg24:
 TRACE regalloc2::ion::dump                    > vreg25:
 TRACE regalloc2::ion::dump                    > vreg26:
 TRACE regalloc2::ion::dump                    > vreg27:
 TRACE regalloc2::ion::dump                    > vreg28:
 TRACE regalloc2::ion::dump                    > vreg29:
 TRACE regalloc2::ion::dump                    > vreg30:
 TRACE regalloc2::ion::dump                    > vreg31:
 TRACE regalloc2::ion::dump                    > vreg32:
 TRACE regalloc2::ion::dump                    > vreg33:
 TRACE regalloc2::ion::dump                    > vreg34:
 TRACE regalloc2::ion::dump                    > vreg35:
 TRACE regalloc2::ion::dump                    > vreg36:
 TRACE regalloc2::ion::dump                    > vreg37:
 TRACE regalloc2::ion::dump                    > vreg38:
 TRACE regalloc2::ion::dump                    > vreg39:
 TRACE regalloc2::ion::dump                    > vreg40:
 TRACE regalloc2::ion::dump                    > vreg41:
 TRACE regalloc2::ion::dump                    > vreg42:
 TRACE regalloc2::ion::dump                    > vreg43:
 TRACE regalloc2::ion::dump                    > vreg44:
 TRACE regalloc2::ion::dump                    > vreg45:
 TRACE regalloc2::ion::dump                    > vreg46:
 TRACE regalloc2::ion::dump                    > vreg47:
 TRACE regalloc2::ion::dump                    > vreg48:
 TRACE regalloc2::ion::dump                    > vreg49:
 TRACE regalloc2::ion::dump                    > vreg50:
 TRACE regalloc2::ion::dump                    > vreg51:
 TRACE regalloc2::ion::dump                    > vreg52:
 TRACE regalloc2::ion::dump                    > vreg53:
 TRACE regalloc2::ion::dump                    > vreg54:
 TRACE regalloc2::ion::dump                    > vreg55:
 TRACE regalloc2::ion::dump                    > vreg56:
 TRACE regalloc2::ion::dump                    > vreg57:
 TRACE regalloc2::ion::dump                    > vreg58:
 TRACE regalloc2::ion::dump                    > vreg59:
 TRACE regalloc2::ion::dump                    > vreg60:
 TRACE regalloc2::ion::dump                    > vreg61:
 TRACE regalloc2::ion::dump                    > vreg62:
 TRACE regalloc2::ion::dump                    > vreg63:
 TRACE regalloc2::ion::dump                    > vreg64:
 TRACE regalloc2::ion::dump                    > vreg65:
 TRACE regalloc2::ion::dump                    > vreg66:
 TRACE regalloc2::ion::dump                    > vreg67:
 TRACE regalloc2::ion::dump                    > vreg68:
 TRACE regalloc2::ion::dump                    > vreg69:
 TRACE regalloc2::ion::dump                    > vreg70:
 TRACE regalloc2::ion::dump                    > vreg71:
 TRACE regalloc2::ion::dump                    > vreg72:
 TRACE regalloc2::ion::dump                    > vreg73:
 TRACE regalloc2::ion::dump                    > vreg74:
 TRACE regalloc2::ion::dump                    > vreg75:
 TRACE regalloc2::ion::dump                    > vreg76:
 TRACE regalloc2::ion::dump                    > vreg77:
 TRACE regalloc2::ion::dump                    > vreg78:
 TRACE regalloc2::ion::dump                    > vreg79:
 TRACE regalloc2::ion::dump                    > vreg80:
 TRACE regalloc2::ion::dump                    > vreg81:
 TRACE regalloc2::ion::dump                    > vreg82:
 TRACE regalloc2::ion::dump                    > vreg83:
 TRACE regalloc2::ion::dump                    > vreg84:
 TRACE regalloc2::ion::dump                    > vreg85:
 TRACE regalloc2::ion::dump                    > vreg86:
 TRACE regalloc2::ion::dump                    > vreg87:
 TRACE regalloc2::ion::dump                    > vreg88:
 TRACE regalloc2::ion::dump                    > vreg89:
 TRACE regalloc2::ion::dump                    > vreg90:
 TRACE regalloc2::ion::dump                    > vreg91:
 TRACE regalloc2::ion::dump                    > vreg92:
 TRACE regalloc2::ion::dump                    > vreg93:
 TRACE regalloc2::ion::dump                    > vreg94:
 TRACE regalloc2::ion::dump                    > vreg95:
 TRACE regalloc2::ion::dump                    > vreg96:
 TRACE regalloc2::ion::dump                    > vreg97:
 TRACE regalloc2::ion::dump                    > vreg98:
 TRACE regalloc2::ion::dump                    > vreg99:
 TRACE regalloc2::ion::dump                    > vreg100:
 TRACE regalloc2::ion::dump                    > vreg101:
 TRACE regalloc2::ion::dump                    > vreg102:
 TRACE regalloc2::ion::dump                    > vreg103:
 TRACE regalloc2::ion::dump                    > vreg104:
 TRACE regalloc2::ion::dump                    > vreg105:
 TRACE regalloc2::ion::dump                    > vreg106:
 TRACE regalloc2::ion::dump                    > vreg107:
 TRACE regalloc2::ion::dump                    > vreg108:
 TRACE regalloc2::ion::dump                    > vreg109:
 TRACE regalloc2::ion::dump                    > vreg110:
 TRACE regalloc2::ion::dump                    > vreg111:
 TRACE regalloc2::ion::dump                    > vreg112:
 TRACE regalloc2::ion::dump                    > vreg113:
 TRACE regalloc2::ion::dump                    > vreg114:
 TRACE regalloc2::ion::dump                    > vreg115:
 TRACE regalloc2::ion::dump                    > vreg116:
 TRACE regalloc2::ion::dump                    > vreg117:
 TRACE regalloc2::ion::dump                    > vreg118:
 TRACE regalloc2::ion::dump                    > vreg119:
 TRACE regalloc2::ion::dump                    > vreg120:
 TRACE regalloc2::ion::dump                    > vreg121:
 TRACE regalloc2::ion::dump                    > vreg122:
 TRACE regalloc2::ion::dump                    > vreg123:
 TRACE regalloc2::ion::dump                    > vreg124:
 TRACE regalloc2::ion::dump                    > vreg125:
 TRACE regalloc2::ion::dump                    > vreg126:
 TRACE regalloc2::ion::dump                    > vreg127:
 TRACE regalloc2::ion::dump                    > vreg128:
 TRACE regalloc2::ion::dump                    > vreg129:
 TRACE regalloc2::ion::dump                    > vreg130:
 TRACE regalloc2::ion::dump                    > vreg131:
 TRACE regalloc2::ion::dump                    > vreg132:
 TRACE regalloc2::ion::dump                    > vreg133:
 TRACE regalloc2::ion::dump                    > vreg134:
 TRACE regalloc2::ion::dump                    > vreg135:
 TRACE regalloc2::ion::dump                    > vreg136:
 TRACE regalloc2::ion::dump                    > vreg137:
 TRACE regalloc2::ion::dump                    > vreg138:
 TRACE regalloc2::ion::dump                    > vreg139:
 TRACE regalloc2::ion::dump                    > vreg140:
 TRACE regalloc2::ion::dump                    > vreg141:
 TRACE regalloc2::ion::dump                    > vreg142:
 TRACE regalloc2::ion::dump                    > vreg143:
 TRACE regalloc2::ion::dump                    > vreg144:
 TRACE regalloc2::ion::dump                    > vreg145:
 TRACE regalloc2::ion::dump                    > vreg146:
 TRACE regalloc2::ion::dump                    > vreg147:
 TRACE regalloc2::ion::dump                    > vreg148:
 TRACE regalloc2::ion::dump                    > vreg149:
 TRACE regalloc2::ion::dump                    > vreg150:
 TRACE regalloc2::ion::dump                    > vreg151:
 TRACE regalloc2::ion::dump                    > vreg152:
 TRACE regalloc2::ion::dump                    > vreg153:
 TRACE regalloc2::ion::dump                    > vreg154:
 TRACE regalloc2::ion::dump                    > vreg155:
 TRACE regalloc2::ion::dump                    > vreg156:
 TRACE regalloc2::ion::dump                    > vreg157:
 TRACE regalloc2::ion::dump                    > vreg158:
 TRACE regalloc2::ion::dump                    > vreg159:
 TRACE regalloc2::ion::dump                    > vreg160:
 TRACE regalloc2::ion::dump                    > vreg161:
 TRACE regalloc2::ion::dump                    > vreg162:
 TRACE regalloc2::ion::dump                    > vreg163:
 TRACE regalloc2::ion::dump                    > vreg164:
 TRACE regalloc2::ion::dump                    > vreg165:
 TRACE regalloc2::ion::dump                    > vreg166:
 TRACE regalloc2::ion::dump                    > vreg167:
 TRACE regalloc2::ion::dump                    > vreg168:
 TRACE regalloc2::ion::dump                    > vreg169:
 TRACE regalloc2::ion::dump                    > vreg170:
 TRACE regalloc2::ion::dump                    > vreg171:
 TRACE regalloc2::ion::dump                    > vreg172:
 TRACE regalloc2::ion::dump                    > vreg173:
 TRACE regalloc2::ion::dump                    > vreg174:
 TRACE regalloc2::ion::dump                    > vreg175:
 TRACE regalloc2::ion::dump                    > vreg176:
 TRACE regalloc2::ion::dump                    > vreg177:
 TRACE regalloc2::ion::dump                    > vreg178:
 TRACE regalloc2::ion::dump                    > vreg179:
 TRACE regalloc2::ion::dump                    > vreg180:
 TRACE regalloc2::ion::dump                    > vreg181:
 TRACE regalloc2::ion::dump                    > vreg182:
 TRACE regalloc2::ion::dump                    > vreg183:
 TRACE regalloc2::ion::dump                    > vreg184:
 TRACE regalloc2::ion::dump                    > vreg185:
 TRACE regalloc2::ion::dump                    > vreg186:
 TRACE regalloc2::ion::dump                    > vreg187:
 TRACE regalloc2::ion::dump                    > vreg188:
 TRACE regalloc2::ion::dump                    > vreg189:
 TRACE regalloc2::ion::dump                    > vreg190:
 TRACE regalloc2::ion::dump                    > vreg191:
 TRACE regalloc2::ion::dump                    > vreg192:
 TRACE regalloc2::ion::dump                    > vreg193:
 TRACE regalloc2::ion::dump                    > vreg194:
 TRACE regalloc2::ion::dump                    >  * range progpoint0-post -- progpoint1-post: range0
 TRACE regalloc2::ion::dump                    > Ranges:
 TRACE regalloc2::ion::dump                    > range0: range=CodeRange { from: progpoint0-post, to: progpoint1-post } vreg=VRegIndex(194) bundle=LiveBundleIndex(0) weight=SpillWeight(8000.0)
 TRACE regalloc2::ion::dump                    >  * use at progpoint0-post (slot 0): Def: v194i reg
 TRACE regalloc2::ion::dump                    >  * use at progpoint1-pre (slot 0): Use: v194i fixed(p0i)
 TRACE regalloc2::ion::process                 > process_bundle: bundle LiveBundleIndex(0) hint PReg(hw = 63, class = Int, index = 63)
 TRACE regalloc2::ion::requirement             > compute_requirement: LiveBundleIndex(0)
 TRACE regalloc2::ion::requirement             >  -> LR LiveRangeIndex(0): CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::requirement             >   -> use Use { operand: Def: v194i reg, pos: progpoint0-post, slot: 0, weight: 35640 }
 TRACE regalloc2::ion::requirement             >      -> req Register
 TRACE regalloc2::ion::requirement             >   -> use Use { operand: Use: v194i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 }
 TRACE regalloc2::ion::requirement             >      -> req FixedReg(PReg(hw = 0, class = Int, index = 0))
 TRACE regalloc2::ion::requirement             >  -> final: FixedReg(PReg(hw = 0, class = Int, index = 0))
 TRACE regalloc2::ion::process                 > attempt 1, req FixedReg(PReg(hw = 0, class = Int, index = 0))
 TRACE regalloc2::ion::process                 > trying preg PRegIndex(0)
 TRACE regalloc2::ion::process                 > try_to_allocate_bundle_to_reg: LiveBundleIndex(0) -> PRegIndex(0)
 TRACE regalloc2::ion::process                 > alloc map for PRegIndex(0) in range LiveRangeKey { from: 1, to: 1 }..: {}
 TRACE regalloc2::ion::process                 >  -> range LR LiveRangeIndex(0): CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::process                 >   -> PReg range None
 TRACE regalloc2::ion::process                 >  -> no more PReg allocations; so no conflict possible!
 TRACE regalloc2::ion::process                 >   -> bundle LiveBundleIndex(0) assigned to preg PReg(hw = 0, class = Int, index = 0)
 TRACE regalloc2::ion::process                 >  -> allocated to any PRegIndex(0)
 TRACE regalloc2::ion::spill                   > allocating regs for spilled bundles
 TRACE regalloc2::ion::spill                   > allocate spillslot: 0
 TRACE regalloc2::ion::spill                   > spillslot allocator done
 TRACE regalloc2::ion::moves                   > apply_allocations_and_insert_moves
 TRACE regalloc2::ion::moves                   > blockparam_ins: []
 TRACE regalloc2::ion::moves                   > blockparam_outs: []
 TRACE regalloc2::ion::moves                   > get_alloc_for_range: LiveRangeIndex(0)
 TRACE regalloc2::ion::moves                   >  -> bundle: LiveBundleIndex(0)
 TRACE regalloc2::ion::moves                   >  -> allocation p0i
 TRACE regalloc2::ion::moves                   > apply_allocations: vreg VRegIndex(194) LR LiveRangeIndex(0) with range CodeRange { from: progpoint0-post, to: progpoint1-post } has alloc p0i
 TRACE regalloc2::ion::moves                   > applying to use: Use { operand: Def: v194i reg, pos: progpoint0-post, slot: 0, weight: 35640 }
 TRACE regalloc2::ion::moves                   > applying to use: Use { operand: Use: v194i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 }
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Register allocation: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode emission, (during Compilation passes)
 TRACE cranelift_codegen::machinst::buffer     > MachBuffer: first 1 labels are for blocks
 TRACE cranelift_codegen::machinst::vcode      > emitting block Block(0)
 TRACE cranelift_codegen::machinst::vcode      >  -> entry block
 TRACE cranelift_codegen::machinst::buffer     > MachBuffer: bind label MachLabel(0) at offset 4
 TRACE cranelift_codegen::machinst::buffer     > enter optimize_branches:
 b = []
 l = [MachLabel(0)]
 f = []
 TRACE cranelift_codegen::machinst::buffer     > leave optimize_branches:
 b = []
 l = [MachLabel(0)]
 f = []
 TRACE cranelift_codegen::machinst::abi        > Epilogue: [movq    %rbp, %rsp, popq    %rbp, ret]
 TRACE cranelift_codegen::machinst::buffer     > enter optimize_branches:
 b = []
 l = []
 f = []
 TRACE cranelift_codegen::machinst::buffer     > leave optimize_branches:
 b = []
 l = []
 f = []
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode emission finalization, (during VCode emission)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode emission finalization: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode emission: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Compilation passes: 1ms
 INFO  cranelift_jit::backend                  > defining function funcid22: function u0:22(i64, i64) system_v {
    sig0 = (i32) -> i8 system_v

block0(v0: i64, v1: i64):
    v2 = load.i32 notrap aligned v1
    v3 = call_indirect sig0, v0(v2)
    store notrap aligned v3, v1
    return
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Compilation passes, (during <no pass>)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::context              > Number of CLIF instructions to optimize: 4
 DEBUG cranelift_codegen::context              > Number of CLIF blocks to optimize: 1
 TRACE cranelift_codegen::context              > Optimizing (opt level Speed):
function u0:22(i64, i64) system_v {
    sig0 = (i32) -> i8 system_v

block0(v0: i64, v1: i64):
    v2 = load.i32 notrap aligned v1
    v3 = call_indirect sig0, v0(v2)
    store notrap aligned v3, v1
    return
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 TRACE cranelift_codegen::legalizer            > Pre-legalization function:
function u0:22(i64, i64) system_v {
    sig0 = (i32) -> i8 system_v

block0(v0: i64, v1: i64):
    v2 = load.i32 notrap aligned v1
    v3 = call_indirect sig0, v0(v2)
    store notrap aligned v3, v1
    return
}

 TRACE cranelift_codegen::legalizer            > Post-legalization function:
function u0:22(i64, i64) system_v {
    sig0 = (i32) -> i8 system_v

block0(v0: i64, v1: i64):
    v2 = load.i32 notrap aligned v1
    v3 = call_indirect sig0, v0(v2)
    store notrap aligned v3, v1
    return
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Remove unreachable blocks, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove unreachable blocks: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dead code elimination, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dead code elimination: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Remove constant phi-nodes, (during Compilation passes)
 DEBUG cranelift_codegen::remove_constant_phis > do_remove_constant_phis: done, 1 iters.   0 formals, of which 0 const.
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove constant phi-nodes: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Egraph based optimizations, (during Compilation passes)
 TRACE cranelift_codegen::context              > About to optimize with egraph phase:
function u0:22(i64, i64) system_v {
    sig0 = (i32) -> i8 system_v

block0(v0: i64, v1: i64):
    v2 = load.i32 notrap aligned v1
    v3 = call_indirect sig0, v0(v2)
    store notrap aligned v3, v1
    return
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Loop analysis, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Loop analysis: 0ms
 TRACE cranelift_codegen::alias_analysis       > alias analysis: input is:
function u0:22(i64, i64) system_v {
    sig0 = (i32) -> i8 system_v

block0(v0: i64, v1: i64):
    v2 = load.i32 notrap aligned v1
    v3 = call_indirect sig0, v0(v2)
    store notrap aligned v3, v1
    return
}

 TRACE cranelift_codegen::alias_analysis       > alias analysis: input to block0 is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst0: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst1: state is LastStores { heap: Some(inst1), table: Some(inst1), vmctx: Some(inst1), other: Some(inst1) }
 TRACE cranelift_codegen::alias_analysis       > after inst2: state is LastStores { heap: Some(inst1), table: Some(inst1), vmctx: Some(inst1), other: Some(inst2) }
 TRACE cranelift_codegen::alias_analysis       > after inst3: state is LastStores { heap: Some(inst1), table: Some(inst1), vmctx: Some(inst1), other: Some(inst2) }
 TRACE cranelift_codegen::egraph               > Processing block block0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for blockparam v0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for blockparam v1
 TRACE cranelift_codegen::egraph               > Processing inst inst0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v2
 TRACE cranelift_codegen::egraph               > rewriting arg v1 of inst inst0 to v1
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst0 with state LastStores { heap: None, table: None, vmctx: None, other: None } (Load { opcode: Load, arg: v1, flags: MemFlags { bits: 1921 }, offset: Offset32(0) })
 TRACE cranelift_codegen::alias_analysis       > alias analysis: at inst0: load with last_store inst18446744073709551615 at loc MemoryLoc { last_store: None, address: v1, offset: Offset32(0), ty: types::I32, extending_opcode: None }
 TRACE cranelift_codegen::alias_analysis       >  -> inserting load result v2 at loc MemoryLoc { last_store: None, address: v1, offset: Offset32(0), ty: types::I32, extending_opcode: None }
 TRACE cranelift_codegen::egraph               > Processing inst inst1
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v3
 TRACE cranelift_codegen::egraph               > rewriting arg v0 of inst inst1 to v0
 TRACE cranelift_codegen::egraph               > rewriting arg v2 of inst inst1 to v2
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst1 with state LastStores { heap: None, table: None, vmctx: None, other: None } (CallIndirect { opcode: CallIndirect, args: EntityList { index: 9, unused: PhantomData<cranelift_codegen::ir::entities::Value> }, sig_ref: sig0 })
 TRACE cranelift_codegen::egraph               > Processing inst inst2
 TRACE cranelift_codegen::egraph               > rewriting arg v3 of inst inst2 to v3
 TRACE cranelift_codegen::egraph               > rewriting arg v1 of inst inst2 to v1
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst2 with state LastStores { heap: Some(inst1), table: Some(inst1), vmctx: Some(inst1), other: Some(inst1) } (Store { opcode: Store, args: [v3, v1], flags: MemFlags { bits: 1921 }, offset: Offset32(0) })
 TRACE cranelift_codegen::alias_analysis       > alias analysis: at inst2: store with data v3 at loc MemoryLoc { last_store: Some(inst2), address: v1, offset: Offset32(0), ty: types::I8, extending_opcode: None }
 TRACE cranelift_codegen::egraph               > Processing inst inst3
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst3 with state LastStores { heap: Some(inst1), table: Some(inst1), vmctx: Some(inst1), other: Some(inst2) } (MultiAry { opcode: Return, args: EntityList { index: 0, unused: PhantomData<cranelift_codegen::ir::entities::Value> } })
 TRACE cranelift_codegen::egraph               > egraph built:
function u0:22(i64, i64) system_v {
    sig0 = (i32) -> i8 system_v

block0(v0: i64, v1: i64):
    v2 = load.i32 notrap aligned v1
    v3 = call_indirect sig0, v0(v2)
    store notrap aligned v3, v1
    return
}


 TRACE cranelift_codegen::egraph               >  -> v0 = Param(block0, 0)
 TRACE cranelift_codegen::egraph               >  -> v1 = Param(block0, 1)
 TRACE cranelift_codegen::egraph               >  -> v2 = Result(inst0, 0)
 TRACE cranelift_codegen::egraph               >   -> inst0 = Load { opcode: Load, arg: v1, flags: MemFlags { bits: 1921 }, offset: Offset32(0) }
 TRACE cranelift_codegen::egraph               >  -> v3 = Result(inst1, 0)
 TRACE cranelift_codegen::egraph               >   -> inst1 = CallIndirect { opcode: CallIndirect, args: EntityList { index: 9, unused: PhantomData<cranelift_codegen::ir::entities::Value> }, sig_ref: sig0 }
 TRACE cranelift_codegen::egraph               > stats: Stats {
    pure_inst: 0,
    pure_inst_deduped: 0,
    skeleton_inst: 4,
    alias_analysis_removed: 0,
    new_inst: 0,
    union: 0,
    subsume: 0,
    remat: 0,
    rewrite_rule_invoked: 0,
    rewrite_depth_limit: 0,
    elaborate_visit_node: 0,
    elaborate_memoize_hit: 0,
    elaborate_memoize_miss: 0,
    elaborate_remat: 0,
    elaborate_licm_hoist: 0,
    elaborate_func: 0,
    elaborate_func_pre_insts: 0,
    elaborate_func_post_insts: 0,
    elaborate_best_cost_fixpoint_iters: 0,
}
 TRACE cranelift_codegen::egraph               > pinned_union_count: 0
 TRACE cranelift_codegen::egraph::elaborate    > Entering fixpoint loop to compute the best values for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 0
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v0 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 1)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v3 def Result(inst1, 0)
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 1
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v0 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 1)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v3 def Result(inst1, 0)
 TRACE cranelift_codegen::egraph::elaborate    > finished fixpoint loop to compute best value for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v0: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v0)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v1: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v1)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v2: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v2)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v3: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v3)
 DEBUG cranelift_codegen::context              > egraph stats: Stats { pure_inst: 0, pure_inst_deduped: 0, skeleton_inst: 4, alias_analysis_removed: 0, new_inst: 0, union: 0, subsume: 0, remat: 0, rewrite_rule_invoked: 0, rewrite_depth_limit: 0, elaborate_visit_node: 0, elaborate_memoize_hit: 0, elaborate_memoize_miss: 0, elaborate_remat: 0, elaborate_licm_hoist: 0, elaborate_func: 1, elaborate_func_pre_insts: 4, elaborate_func_post_insts: 4, elaborate_best_cost_fixpoint_iters: 2 }
 TRACE cranelift_codegen::context              > pinned_union_count: 0
 TRACE cranelift_codegen::context              > After egraph optimization:
function u0:22(i64, i64) system_v {
    sig0 = (i32) -> i8 system_v

block0(v0: i64, v1: i64):
    return
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Egraph based optimizations: 0ms
 TRACE cranelift_codegen::machinst::abi        > ABISig: sig Signature { params: [AbiParam { value_type: types::I64, purpose: Normal, extension: None }, AbiParam { value_type: types::I64, purpose: Normal, extension: None }], returns: [], call_conv: SystemV } => args end = 2 rets end = 0
             arg stack = 0 ret stack = 0 stack_ret_arg = false
 TRACE cranelift_codegen::machinst::abi        > ABISig: sig Signature { params: [AbiParam { value_type: types::I32, purpose: Normal, extension: None }], returns: [AbiParam { value_type: types::I8, purpose: Normal, extension: None }], call_conv: SystemV } => args end = 4 rets end = 3
             arg stack = 0 ret stack = 0 stack_ret_arg = false
 TRACE cranelift_codegen::machinst::abi        > ABI: func signature Signature { params: [AbiParam { value_type: types::I64, purpose: Normal, extension: None }, AbiParam { value_type: types::I64, purpose: Normal, extension: None }], returns: [], call_conv: SystemV }
 TRACE cranelift_codegen::machinst::blockorder > BlockLoweringOrder: function body function u0:22(i64, i64) system_v {
    sig0 = (i32) -> i8 system_v

block0(v0: i64, v1: i64):
    return
}

 TRACE cranelift_codegen::machinst::blockorder > BlockLoweringOrder: BlockLoweringOrder {
    lowered_order: [
        Orig {
            block: block0,
        },
    ],
    lowered_succ_indices: [],
    lowered_succ_ranges: [
        (
            None,
            0..0,
        ),
    ],
    cold_blocks: {},
    indirect_branch_targets: {},
}
 TRACE cranelift_codegen::machinst::lower      > bb block0 param v0: regs ValueRegs { parts: [v192, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > bb block0 param v1: regs ValueRegs { parts: [v193, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > bb block0 inst inst3 has color 1
 TRACE cranelift_codegen::machinst::lower      >  -> side-effecting; incrementing color for next inst
 DEBUG cranelift_codegen::machinst::compile    > Number of CLIF instructions to lower: 4
 DEBUG cranelift_codegen::machinst::compile    > Number of CLIF blocks to lower: 1
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode lowering, (during Compilation passes)
 TRACE cranelift_codegen::machinst::lower      > about to lower function: function u0:22(i64, i64) system_v {
    sig0 = (i32) -> i8 system_v

block0(v0: i64, v1: i64):
    return
}

 TRACE cranelift_codegen::machinst::lower      > lower_clif_block: block block0 inst inst3 (MultiAry { opcode: Return, args: EntityList { index: 0, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }) is_branch false side_effect true value_needed false
 TRACE cranelift_codegen::machinst::lower      > lowering: inst inst3: MultiAry { opcode: Return, args: EntityList { index: 0, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }
 TRACE cranelift_codegen::machinst::lower      > emit: rets
 TRACE cranelift_codegen::machinst::lower      > gen_arg_setup: entry BB block0 args are:
[v0, v1]
 TRACE cranelift_codegen::machinst::abi        > gen_retval_area_setup: not needed
 TRACE cranelift_codegen::machinst::lower      > built vcode:
VRegAllocator {
}
Backwards VCode {
  Entry block: 0
Block 0:
    (original IR block: block0)
  Inst 0: rets
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode lowering: 0ms
 DEBUG cranelift_codegen::machinst::compile    > Number of lowered vcode instructions: 1
 DEBUG cranelift_codegen::machinst::compile    > Number of lowered vcode blocks: 1
 TRACE cranelift_codegen::machinst::compile    > vcode from lowering: 
VCode {
  Entry block: 0
Block 0:
    (original IR block: block0)
  Inst 0: rets
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Register allocation, (during Compilation passes)
 TRACE regalloc2::ion::liveranges              > computing liveins for block0
 TRACE regalloc2::ion::liveranges              >  -> initial liveout set: []
 TRACE regalloc2::ion::liveranges              > computed liveins at block0: []
 TRACE regalloc2::ion::merge                   > merge_vreg_bundles: creating vreg bundles
 TRACE regalloc2::ion::merge                   > done merging bundles
 TRACE regalloc2::ion::dump                    > Bundles:
 TRACE regalloc2::ion::dump                    > VRegs:
 TRACE regalloc2::ion::dump                    > vreg0:
 TRACE regalloc2::ion::dump                    > vreg1:
 TRACE regalloc2::ion::dump                    > vreg2:
 TRACE regalloc2::ion::dump                    > vreg3:
 TRACE regalloc2::ion::dump                    > vreg4:
 TRACE regalloc2::ion::dump                    > vreg5:
 TRACE regalloc2::ion::dump                    > vreg6:
 TRACE regalloc2::ion::dump                    > vreg7:
 TRACE regalloc2::ion::dump                    > vreg8:
 TRACE regalloc2::ion::dump                    > vreg9:
 TRACE regalloc2::ion::dump                    > vreg10:
 TRACE regalloc2::ion::dump                    > vreg11:
 TRACE regalloc2::ion::dump                    > vreg12:
 TRACE regalloc2::ion::dump                    > vreg13:
 TRACE regalloc2::ion::dump                    > vreg14:
 TRACE regalloc2::ion::dump                    > vreg15:
 TRACE regalloc2::ion::dump                    > vreg16:
 TRACE regalloc2::ion::dump                    > vreg17:
 TRACE regalloc2::ion::dump                    > vreg18:
 TRACE regalloc2::ion::dump                    > vreg19:
 TRACE regalloc2::ion::dump                    > vreg20:
 TRACE regalloc2::ion::dump                    > vreg21:
 TRACE regalloc2::ion::dump                    > vreg22:
 TRACE regalloc2::ion::dump                    > vreg23:
 TRACE regalloc2::ion::dump                    > vreg24:
 TRACE regalloc2::ion::dump                    > vreg25:
 TRACE regalloc2::ion::dump                    > vreg26:
 TRACE regalloc2::ion::dump                    > vreg27:
 TRACE regalloc2::ion::dump                    > vreg28:
 TRACE regalloc2::ion::dump                    > vreg29:
 TRACE regalloc2::ion::dump                    > vreg30:
 TRACE regalloc2::ion::dump                    > vreg31:
 TRACE regalloc2::ion::dump                    > vreg32:
 TRACE regalloc2::ion::dump                    > vreg33:
 TRACE regalloc2::ion::dump                    > vreg34:
 TRACE regalloc2::ion::dump                    > vreg35:
 TRACE regalloc2::ion::dump                    > vreg36:
 TRACE regalloc2::ion::dump                    > vreg37:
 TRACE regalloc2::ion::dump                    > vreg38:
 TRACE regalloc2::ion::dump                    > vreg39:
 TRACE regalloc2::ion::dump                    > vreg40:
 TRACE regalloc2::ion::dump                    > vreg41:
 TRACE regalloc2::ion::dump                    > vreg42:
 TRACE regalloc2::ion::dump                    > vreg43:
 TRACE regalloc2::ion::dump                    > vreg44:
 TRACE regalloc2::ion::dump                    > vreg45:
 TRACE regalloc2::ion::dump                    > vreg46:
 TRACE regalloc2::ion::dump                    > vreg47:
 TRACE regalloc2::ion::dump                    > vreg48:
 TRACE regalloc2::ion::dump                    > vreg49:
 TRACE regalloc2::ion::dump                    > vreg50:
 TRACE regalloc2::ion::dump                    > vreg51:
 TRACE regalloc2::ion::dump                    > vreg52:
 TRACE regalloc2::ion::dump                    > vreg53:
 TRACE regalloc2::ion::dump                    > vreg54:
 TRACE regalloc2::ion::dump                    > vreg55:
 TRACE regalloc2::ion::dump                    > vreg56:
 TRACE regalloc2::ion::dump                    > vreg57:
 TRACE regalloc2::ion::dump                    > vreg58:
 TRACE regalloc2::ion::dump                    > vreg59:
 TRACE regalloc2::ion::dump                    > vreg60:
 TRACE regalloc2::ion::dump                    > vreg61:
 TRACE regalloc2::ion::dump                    > vreg62:
 TRACE regalloc2::ion::dump                    > vreg63:
 TRACE regalloc2::ion::dump                    > vreg64:
 TRACE regalloc2::ion::dump                    > vreg65:
 TRACE regalloc2::ion::dump                    > vreg66:
 TRACE regalloc2::ion::dump                    > vreg67:
 TRACE regalloc2::ion::dump                    > vreg68:
 TRACE regalloc2::ion::dump                    > vreg69:
 TRACE regalloc2::ion::dump                    > vreg70:
 TRACE regalloc2::ion::dump                    > vreg71:
 TRACE regalloc2::ion::dump                    > vreg72:
 TRACE regalloc2::ion::dump                    > vreg73:
 TRACE regalloc2::ion::dump                    > vreg74:
 TRACE regalloc2::ion::dump                    > vreg75:
 TRACE regalloc2::ion::dump                    > vreg76:
 TRACE regalloc2::ion::dump                    > vreg77:
 TRACE regalloc2::ion::dump                    > vreg78:
 TRACE regalloc2::ion::dump                    > vreg79:
 TRACE regalloc2::ion::dump                    > vreg80:
 TRACE regalloc2::ion::dump                    > vreg81:
 TRACE regalloc2::ion::dump                    > vreg82:
 TRACE regalloc2::ion::dump                    > vreg83:
 TRACE regalloc2::ion::dump                    > vreg84:
 TRACE regalloc2::ion::dump                    > vreg85:
 TRACE regalloc2::ion::dump                    > vreg86:
 TRACE regalloc2::ion::dump                    > vreg87:
 TRACE regalloc2::ion::dump                    > vreg88:
 TRACE regalloc2::ion::dump                    > vreg89:
 TRACE regalloc2::ion::dump                    > vreg90:
 TRACE regalloc2::ion::dump                    > vreg91:
 TRACE regalloc2::ion::dump                    > vreg92:
 TRACE regalloc2::ion::dump                    > vreg93:
 TRACE regalloc2::ion::dump                    > vreg94:
 TRACE regalloc2::ion::dump                    > vreg95:
 TRACE regalloc2::ion::dump                    > vreg96:
 TRACE regalloc2::ion::dump                    > vreg97:
 TRACE regalloc2::ion::dump                    > vreg98:
 TRACE regalloc2::ion::dump                    > vreg99:
 TRACE regalloc2::ion::dump                    > vreg100:
 TRACE regalloc2::ion::dump                    > vreg101:
 TRACE regalloc2::ion::dump                    > vreg102:
 TRACE regalloc2::ion::dump                    > vreg103:
 TRACE regalloc2::ion::dump                    > vreg104:
 TRACE regalloc2::ion::dump                    > vreg105:
 TRACE regalloc2::ion::dump                    > vreg106:
 TRACE regalloc2::ion::dump                    > vreg107:
 TRACE regalloc2::ion::dump                    > vreg108:
 TRACE regalloc2::ion::dump                    > vreg109:
 TRACE regalloc2::ion::dump                    > vreg110:
 TRACE regalloc2::ion::dump                    > vreg111:
 TRACE regalloc2::ion::dump                    > vreg112:
 TRACE regalloc2::ion::dump                    > vreg113:
 TRACE regalloc2::ion::dump                    > vreg114:
 TRACE regalloc2::ion::dump                    > vreg115:
 TRACE regalloc2::ion::dump                    > vreg116:
 TRACE regalloc2::ion::dump                    > vreg117:
 TRACE regalloc2::ion::dump                    > vreg118:
 TRACE regalloc2::ion::dump                    > vreg119:
 TRACE regalloc2::ion::dump                    > vreg120:
 TRACE regalloc2::ion::dump                    > vreg121:
 TRACE regalloc2::ion::dump                    > vreg122:
 TRACE regalloc2::ion::dump                    > vreg123:
 TRACE regalloc2::ion::dump                    > vreg124:
 TRACE regalloc2::ion::dump                    > vreg125:
 TRACE regalloc2::ion::dump                    > vreg126:
 TRACE regalloc2::ion::dump                    > vreg127:
 TRACE regalloc2::ion::dump                    > vreg128:
 TRACE regalloc2::ion::dump                    > vreg129:
 TRACE regalloc2::ion::dump                    > vreg130:
 TRACE regalloc2::ion::dump                    > vreg131:
 TRACE regalloc2::ion::dump                    > vreg132:
 TRACE regalloc2::ion::dump                    > vreg133:
 TRACE regalloc2::ion::dump                    > vreg134:
 TRACE regalloc2::ion::dump                    > vreg135:
 TRACE regalloc2::ion::dump                    > vreg136:
 TRACE regalloc2::ion::dump                    > vreg137:
 TRACE regalloc2::ion::dump                    > vreg138:
 TRACE regalloc2::ion::dump                    > vreg139:
 TRACE regalloc2::ion::dump                    > vreg140:
 TRACE regalloc2::ion::dump                    > vreg141:
 TRACE regalloc2::ion::dump                    > vreg142:
 TRACE regalloc2::ion::dump                    > vreg143:
 TRACE regalloc2::ion::dump                    > vreg144:
 TRACE regalloc2::ion::dump                    > vreg145:
 TRACE regalloc2::ion::dump                    > vreg146:
 TRACE regalloc2::ion::dump                    > vreg147:
 TRACE regalloc2::ion::dump                    > vreg148:
 TRACE regalloc2::ion::dump                    > vreg149:
 TRACE regalloc2::ion::dump                    > vreg150:
 TRACE regalloc2::ion::dump                    > vreg151:
 TRACE regalloc2::ion::dump                    > vreg152:
 TRACE regalloc2::ion::dump                    > vreg153:
 TRACE regalloc2::ion::dump                    > vreg154:
 TRACE regalloc2::ion::dump                    > vreg155:
 TRACE regalloc2::ion::dump                    > vreg156:
 TRACE regalloc2::ion::dump                    > vreg157:
 TRACE regalloc2::ion::dump                    > vreg158:
 TRACE regalloc2::ion::dump                    > vreg159:
 TRACE regalloc2::ion::dump                    > vreg160:
 TRACE regalloc2::ion::dump                    > vreg161:
 TRACE regalloc2::ion::dump                    > vreg162:
 TRACE regalloc2::ion::dump                    > vreg163:
 TRACE regalloc2::ion::dump                    > vreg164:
 TRACE regalloc2::ion::dump                    > vreg165:
 TRACE regalloc2::ion::dump                    > vreg166:
 TRACE regalloc2::ion::dump                    > vreg167:
 TRACE regalloc2::ion::dump                    > vreg168:
 TRACE regalloc2::ion::dump                    > vreg169:
 TRACE regalloc2::ion::dump                    > vreg170:
 TRACE regalloc2::ion::dump                    > vreg171:
 TRACE regalloc2::ion::dump                    > vreg172:
 TRACE regalloc2::ion::dump                    > vreg173:
 TRACE regalloc2::ion::dump                    > vreg174:
 TRACE regalloc2::ion::dump                    > vreg175:
 TRACE regalloc2::ion::dump                    > vreg176:
 TRACE regalloc2::ion::dump                    > vreg177:
 TRACE regalloc2::ion::dump                    > vreg178:
 TRACE regalloc2::ion::dump                    > vreg179:
 TRACE regalloc2::ion::dump                    > vreg180:
 TRACE regalloc2::ion::dump                    > vreg181:
 TRACE regalloc2::ion::dump                    > vreg182:
 TRACE regalloc2::ion::dump                    > vreg183:
 TRACE regalloc2::ion::dump                    > vreg184:
 TRACE regalloc2::ion::dump                    > vreg185:
 TRACE regalloc2::ion::dump                    > vreg186:
 TRACE regalloc2::ion::dump                    > vreg187:
 TRACE regalloc2::ion::dump                    > vreg188:
 TRACE regalloc2::ion::dump                    > vreg189:
 TRACE regalloc2::ion::dump                    > vreg190:
 TRACE regalloc2::ion::dump                    > vreg191:
 TRACE regalloc2::ion::dump                    > vreg192:
 TRACE regalloc2::ion::dump                    > vreg193:
 TRACE regalloc2::ion::dump                    > Ranges:
 TRACE regalloc2::ion::spill                   > allocating regs for spilled bundles
 TRACE regalloc2::ion::spill                   > spillslot allocator done
 TRACE regalloc2::ion::moves                   > apply_allocations_and_insert_moves
 TRACE regalloc2::ion::moves                   > blockparam_ins: []
 TRACE regalloc2::ion::moves                   > blockparam_outs: []
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Register allocation: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode emission, (during Compilation passes)
 TRACE cranelift_codegen::machinst::buffer     > MachBuffer: first 1 labels are for blocks
 TRACE cranelift_codegen::machinst::vcode      > emitting block Block(0)
 TRACE cranelift_codegen::machinst::vcode      >  -> entry block
 TRACE cranelift_codegen::machinst::buffer     > MachBuffer: bind label MachLabel(0) at offset 4
 TRACE cranelift_codegen::machinst::buffer     > enter optimize_branches:
 b = []
 l = [MachLabel(0)]
 f = []
 TRACE cranelift_codegen::machinst::buffer     > leave optimize_branches:
 b = []
 l = [MachLabel(0)]
 f = []
 TRACE cranelift_codegen::machinst::abi        > Epilogue: [movq    %rbp, %rsp, popq    %rbp, ret]
 TRACE cranelift_codegen::machinst::buffer     > enter optimize_branches:
 b = []
 l = []
 f = []
 TRACE cranelift_codegen::machinst::buffer     > leave optimize_branches:
 b = []
 l = []
 f = []
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode emission finalization, (during VCode emission)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode emission finalization: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode emission: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Compilation passes: 1ms
 INFO  cranelift_jit::backend                  > defining function funcid2: function u0:2(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp sge v2, v3  ; v3 = 0
    return v4
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Compilation passes, (during <no pass>)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::context              > Number of CLIF instructions to optimize: 4
 DEBUG cranelift_codegen::context              > Number of CLIF blocks to optimize: 1
 TRACE cranelift_codegen::context              > Optimizing (opt level Speed):
function u0:2(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp sge v2, v3  ; v3 = 0
    return v4
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 TRACE cranelift_codegen::legalizer            > Pre-legalization function:
function u0:2(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp sge v2, v3  ; v3 = 0
    return v4
}

 TRACE cranelift_codegen::legalizer            > Post-legalization function:
function u0:2(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp sge v2, v3  ; v3 = 0
    return v4
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Remove unreachable blocks, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove unreachable blocks: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dead code elimination, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dead code elimination: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Remove constant phi-nodes, (during Compilation passes)
 DEBUG cranelift_codegen::remove_constant_phis > do_remove_constant_phis: done, 1 iters.   0 formals, of which 0 const.
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove constant phi-nodes: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Egraph based optimizations, (during Compilation passes)
 TRACE cranelift_codegen::context              > About to optimize with egraph phase:
function u0:2(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp sge v2, v3  ; v3 = 0
    return v4
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Loop analysis, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Loop analysis: 0ms
 TRACE cranelift_codegen::alias_analysis       > alias analysis: input is:
function u0:2(i32) -> i8 system_v {
block0(v1: i32):
    v2 = uextend.i64 v1
    v3 = iconst.i64 0
    v4 = icmp sge v2, v3  ; v3 = 0
    return v4
}

 TRACE cranelift_codegen::alias_analysis       > alias analysis: input to block0 is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst0: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst1: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst2: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst3: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::egraph               > Processing block block0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for blockparam v1
 TRACE cranelift_codegen::egraph               > Processing inst inst0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v2
 TRACE cranelift_codegen::egraph               > rewriting arg v1 of inst inst0 to v1
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v2
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > iter: value v1
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v2 -> [v2]
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst1
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v3
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v3
 TRACE cranelift_codegen::opts                 > iter: value v3
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > remat: v3
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v3 -> [v3, v3]
 TRACE cranelift_codegen::egraph               > Returned from ISLE for v3, got v3
 TRACE cranelift_codegen::egraph               >  -> same as orig value; skipping
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst2
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v4
 TRACE cranelift_codegen::egraph               > rewriting arg v2 of inst inst2 to v2
 TRACE cranelift_codegen::egraph               > rewriting arg v3 of inst inst2 to v3
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v4
 TRACE cranelift_codegen::opts                 > iter: value v4
 TRACE cranelift_codegen::opts                 >  -> value of type i8
 TRACE cranelift_codegen::opts                 > iter: value v3
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 2
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v5
 TRACE cranelift_codegen::opts                 > iter: value v5
 TRACE cranelift_codegen::opts                 >  -> value of type i8
 TRACE cranelift_codegen::opts                 > remat: v5
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v5 -> [v5, v5]
 TRACE cranelift_codegen::egraph               > Returned from ISLE for v5, got v5
 TRACE cranelift_codegen::egraph               >  -> same as orig value; skipping
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 1
 TRACE cranelift_codegen::opts                 > make_inst_ctor: UnaryImm { opcode: Iconst, imm: Imm64(1) } -> v5
 TRACE cranelift_codegen::opts                 > subsume: v5
 TRACE cranelift_codegen::opts                 > iter: value v3
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v4 -> [v5, v4]
 TRACE cranelift_codegen::egraph               > Returned from ISLE for v4, got v5
 TRACE cranelift_codegen::unionfind            > union: v5, v4
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst3
 TRACE cranelift_codegen::egraph               > rewriting arg v4 of inst inst3 to v5
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst3 with state LastStores { heap: None, table: None, vmctx: None, other: None } (MultiAry { opcode: Return, args: EntityList { index: 17, unused: PhantomData<cranelift_codegen::ir::entities::Value> } })
 TRACE cranelift_codegen::egraph               > egraph built:
function u0:2(i32) -> i8 system_v {
block0(v1: i32):
    return v5  ; v5 = 1
}


 TRACE cranelift_codegen::egraph               >  -> v1 = Param(block0, 0)
 TRACE cranelift_codegen::egraph               >  -> v2 = Result(inst0, 0)
 TRACE cranelift_codegen::egraph               >   -> inst0 = Unary { opcode: Uextend, arg: v1 }
 TRACE cranelift_codegen::egraph               >  -> v3 = Result(inst1, 0)
 TRACE cranelift_codegen::egraph               >   -> inst1 = UnaryImm { opcode: Iconst, imm: Imm64(0) }
 TRACE cranelift_codegen::egraph               >  -> v4 = Result(inst2, 0)
 TRACE cranelift_codegen::egraph               >   -> inst2 = IntCompare { opcode: Icmp, args: [v2, v3], cond: SignedGreaterThanOrEqual }
 TRACE cranelift_codegen::egraph               >  -> v5 = Result(inst4, 0)
 TRACE cranelift_codegen::egraph               >   -> inst4 = UnaryImm { opcode: Iconst, imm: Imm64(1) }
 TRACE cranelift_codegen::egraph               > stats: Stats {
    pure_inst: 4,
    pure_inst_deduped: 0,
    skeleton_inst: 1,
    alias_analysis_removed: 0,
    new_inst: 1,
    union: 0,
    subsume: 1,
    remat: 2,
    rewrite_rule_invoked: 4,
    rewrite_depth_limit: 0,
    elaborate_visit_node: 0,
    elaborate_memoize_hit: 0,
    elaborate_memoize_miss: 0,
    elaborate_remat: 0,
    elaborate_licm_hoist: 0,
    elaborate_func: 0,
    elaborate_func_pre_insts: 0,
    elaborate_func_post_insts: 0,
    elaborate_best_cost_fixpoint_iters: 0,
}
 TRACE cranelift_codegen::egraph               > pinned_union_count: 0
 TRACE cranelift_codegen::egraph::elaborate    > Entering fixpoint loop to compute the best values for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 0
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v2 = Cost::Finite { op_cost: 2, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v3 def Result(inst1, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v3 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v4 def Result(inst2, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v4 = Cost::Finite { op_cost: 7, depth: 2 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v5 def Result(inst4, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v5 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 1
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v2 = Cost::Finite { op_cost: 2, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v3 def Result(inst1, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v3 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v4 def Result(inst2, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v4 = Cost::Finite { op_cost: 7, depth: 2 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v5 def Result(inst4, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v5 = Cost::Finite { op_cost: 1, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > finished fixpoint loop to compute best value for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v1: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v1)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v2: BestEntry(Cost::Finite { op_cost: 2, depth: 1 }, v2)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v3: BestEntry(Cost::Finite { op_cost: 1, depth: 1 }, v3)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v4: BestEntry(Cost::Finite { op_cost: 7, depth: 2 }, v4)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v5: BestEntry(Cost::Finite { op_cost: 1, depth: 1 }, v5)
 TRACE cranelift_codegen::egraph::elaborate    > need inst inst4 before inst3
 TRACE cranelift_codegen::egraph::elaborate    >  -> no location; using original inst
 TRACE cranelift_codegen::egraph::elaborate    >  -> inserting identity mapping for v5
 TRACE cranelift_codegen::egraph::elaborate    >  -> Terminator elab arg v5 is best value is v5
 DEBUG cranelift_codegen::context              > egraph stats: Stats { pure_inst: 4, pure_inst_deduped: 0, skeleton_inst: 1, alias_analysis_removed: 0, new_inst: 1, union: 0, subsume: 1, remat: 2, rewrite_rule_invoked: 4, rewrite_depth_limit: 0, elaborate_visit_node: 0, elaborate_memoize_hit: 0, elaborate_memoize_miss: 0, elaborate_remat: 0, elaborate_licm_hoist: 0, elaborate_func: 1, elaborate_func_pre_insts: 5, elaborate_func_post_insts: 5, elaborate_best_cost_fixpoint_iters: 2 }
 TRACE cranelift_codegen::context              > pinned_union_count: 0
 TRACE cranelift_codegen::context              > After egraph optimization:
function u0:2(i32) -> i8 system_v {
block0(v1: i32):
    v5 = iconst.i8 1
    return v5  ; v5 = 1
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Egraph based optimizations: 0ms
 TRACE cranelift_codegen::machinst::abi        > ABISig: sig Signature { params: [AbiParam { value_type: types::I32, purpose: Normal, extension: None }], returns: [AbiParam { value_type: types::I8, purpose: Normal, extension: None }], call_conv: SystemV } => args end = 2 rets end = 1
             arg stack = 0 ret stack = 0 stack_ret_arg = false
 TRACE cranelift_codegen::machinst::abi        > ABI: func signature Signature { params: [AbiParam { value_type: types::I32, purpose: Normal, extension: None }], returns: [AbiParam { value_type: types::I8, purpose: Normal, extension: None }], call_conv: SystemV }
 TRACE cranelift_codegen::machinst::blockorder > BlockLoweringOrder: function body function u0:2(i32) -> i8 system_v {
block0(v1: i32):
    v5 = iconst.i8 1
    return v5  ; v5 = 1
}

 TRACE cranelift_codegen::machinst::blockorder > BlockLoweringOrder: BlockLoweringOrder {
    lowered_order: [
        Orig {
            block: block0,
        },
    ],
    lowered_succ_indices: [],
    lowered_succ_ranges: [
        (
            None,
            0..0,
        ),
    ],
    cold_blocks: {},
    indirect_branch_targets: {},
}
 TRACE cranelift_codegen::machinst::lower      > bb block0 param v1: regs ValueRegs { parts: [v192, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > bb block0 inst inst4 (UnaryImm { opcode: Iconst, imm: Imm64(1) }): result v5 regs ValueRegs { parts: [v193, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > bb block0 inst inst4 has color 1
 TRACE cranelift_codegen::machinst::lower      >  -> constant: 1
 TRACE cranelift_codegen::machinst::lower      > bb block0 inst inst3 has color 1
 TRACE cranelift_codegen::machinst::lower      >  -> side-effecting; incrementing color for next inst
 TRACE cranelift_codegen::machinst::lower      > arg v5 used, old state Unused, new Once
 DEBUG cranelift_codegen::machinst::compile    > Number of CLIF instructions to lower: 5
 DEBUG cranelift_codegen::machinst::compile    > Number of CLIF blocks to lower: 1
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode lowering, (during Compilation passes)
 TRACE cranelift_codegen::machinst::lower      > about to lower function: function u0:2(i32) -> i8 system_v {
block0(v1: i32):
    v5 = iconst.i8 1
    return v5  ; v5 = 1
}

 TRACE cranelift_codegen::machinst::lower      > lower_clif_block: block block0 inst inst3 (MultiAry { opcode: Return, args: EntityList { index: 17, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }) is_branch false side_effect true value_needed false
 TRACE cranelift_codegen::machinst::lower      > lowering: inst inst3: MultiAry { opcode: Return, args: EntityList { index: 17, unused: PhantomData<cranelift_codegen::ir::entities::Value> } }
 TRACE cranelift_codegen::machinst::lower      > put_value_in_regs: val v5
 TRACE cranelift_codegen::machinst::lower      >  -> regs ValueRegs { parts: [v193, v2097151] }
 TRACE cranelift_codegen::machinst::lower      > emit: rets %v193=%rax
 TRACE cranelift_codegen::machinst::lower      > lower_clif_block: block block0 inst inst4 (UnaryImm { opcode: Iconst, imm: Imm64(1) }) is_branch false side_effect false value_needed true
 TRACE cranelift_codegen::machinst::lower      > lowering: inst inst4: UnaryImm { opcode: Iconst, imm: Imm64(1) }
 TRACE cranelift_codegen::machinst::lower      > emit: movl    $1, %v194l
 TRACE cranelift_codegen::machinst::lower      > set vreg alias: v5 = v193, lowering = v194
 TRACE cranelift_codegen::machinst::lower      > gen_arg_setup: entry BB block0 args are:
[v1]
 TRACE cranelift_codegen::machinst::abi        > gen_retval_area_setup: not needed
 TRACE cranelift_codegen::machinst::lower      > built vcode:
VRegAllocator {
  v193 := v194
}
Backwards VCode {
  Entry block: 0
Block 0:
    (original IR block: block0)
  Inst 0: rets %v193=%rax
  Inst 1: movl    $1, %v194l
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode lowering: 0ms
 DEBUG cranelift_codegen::machinst::compile    > Number of lowered vcode instructions: 2
 DEBUG cranelift_codegen::machinst::compile    > Number of lowered vcode blocks: 1
 TRACE cranelift_codegen::machinst::compile    > vcode from lowering: 
VCode {
  Entry block: 0
Block 0:
    (original IR block: block0)
  Inst 0: movl    $1, %v194l
  Inst 1: rets %v194=%rax
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Register allocation, (during Compilation passes)
 TRACE regalloc2::ion::liveranges              > computing liveins for block0
 TRACE regalloc2::ion::liveranges              >  -> initial liveout set: []
 TRACE regalloc2::ion::liveranges              > op Use: v194i fixed(p0i) was_live = false
 TRACE regalloc2::ion::liveranges              > op Def: v194i reg was_live = true
 TRACE regalloc2::ion::liveranges              > computed liveins at block0: []
 TRACE regalloc2::ion::liveranges              > processing inst1 operand at progpoint1-pre: Use: v194i fixed(p0i)
 TRACE regalloc2::ion::liveranges              > add_liverange_to_vreg: vreg VRegIndex(194) range CodeRange { from: progpoint0-pre, to: progpoint1-post }
 TRACE regalloc2::ion::liveranges              > Use of Use: v194i fixed(p0i) at progpoint1-pre -> LiveRangeIndex(0)
 TRACE regalloc2::ion::liveranges              > insert use Use { operand: Use: v194i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 } into lr LiveRangeIndex(0) with weight SpillWeight(3000.0)
 TRACE regalloc2::ion::liveranges              >   -> now range has weight SpillWeight(3000.0)
 TRACE regalloc2::ion::liveranges              > processing inst0 operand at progpoint0-post: Def: v194i reg
 TRACE regalloc2::ion::liveranges              > Def of v194 at progpoint0-post
 TRACE regalloc2::ion::liveranges              >  -> has existing LR LiveRangeIndex(0)
 TRACE regalloc2::ion::liveranges              > insert use Use { operand: Def: v194i reg, pos: progpoint0-post, slot: 0, weight: 35640 } into lr LiveRangeIndex(0) with weight SpillWeight(5000.0)
 TRACE regalloc2::ion::liveranges              >   -> now range has weight SpillWeight(8000.0)
 TRACE regalloc2::ion::liveranges              >  -> started at block start; trimming to progpoint0-post
 TRACE regalloc2::ion::liveranges              > multi-fixed-reg cleanup: vreg VRegIndex(194) range LiveRangeIndex(0)
 TRACE regalloc2::ion::merge                   > merge_vreg_bundles: creating vreg bundles
 TRACE regalloc2::ion::merge                   > vreg v194 gets bundle0
 TRACE regalloc2::ion::merge                   >  -> with LR range0: CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::merge                   > done merging bundles
 TRACE regalloc2::ion::merge                   > enqueueing bundle0
 TRACE regalloc2::ion::merge                   >  -> prio 1
 TRACE regalloc2::ion::process                 > recompute bundle properties: bundle LiveBundleIndex(0)
 TRACE regalloc2::ion::process                 >   -> use: Use { operand: Def: v194i reg, pos: progpoint0-post, slot: 0, weight: 35640 }
 TRACE regalloc2::ion::process                 >   -> use: Use { operand: Use: v194i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 }
 TRACE regalloc2::ion::process                 >   -> fixed operand at progpoint1-pre: Use: v194i fixed(p0i)
 TRACE regalloc2::ion::process                 >   -> first range has range CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::process                 >   -> minimal: false
 TRACE regalloc2::ion::process                 >   -> uses spill weight: +SpillWeight(8000.0)
 TRACE regalloc2::ion::process                 >  -> dividing by prio 1; final weight 8000
 TRACE regalloc2::ion::dump                    > Bundles:
 TRACE regalloc2::ion::dump                    > bundle0: spillset=SpillSetIndex(0) alloc=none
 TRACE regalloc2::ion::dump                    >  * range progpoint0-post -- progpoint1-post: range0
 TRACE regalloc2::ion::dump                    > VRegs:
 TRACE regalloc2::ion::dump                    > vreg0:
 TRACE regalloc2::ion::dump                    > vreg1:
 TRACE regalloc2::ion::dump                    > vreg2:
 TRACE regalloc2::ion::dump                    > vreg3:
 TRACE regalloc2::ion::dump                    > vreg4:
 TRACE regalloc2::ion::dump                    > vreg5:
 TRACE regalloc2::ion::dump                    > vreg6:
 TRACE regalloc2::ion::dump                    > vreg7:
 TRACE regalloc2::ion::dump                    > vreg8:
 TRACE regalloc2::ion::dump                    > vreg9:
 TRACE regalloc2::ion::dump                    > vreg10:
 TRACE regalloc2::ion::dump                    > vreg11:
 TRACE regalloc2::ion::dump                    > vreg12:
 TRACE regalloc2::ion::dump                    > vreg13:
 TRACE regalloc2::ion::dump                    > vreg14:
 TRACE regalloc2::ion::dump                    > vreg15:
 TRACE regalloc2::ion::dump                    > vreg16:
 TRACE regalloc2::ion::dump                    > vreg17:
 TRACE regalloc2::ion::dump                    > vreg18:
 TRACE regalloc2::ion::dump                    > vreg19:
 TRACE regalloc2::ion::dump                    > vreg20:
 TRACE regalloc2::ion::dump                    > vreg21:
 TRACE regalloc2::ion::dump                    > vreg22:
 TRACE regalloc2::ion::dump                    > vreg23:
 TRACE regalloc2::ion::dump                    > vreg24:
 TRACE regalloc2::ion::dump                    > vreg25:
 TRACE regalloc2::ion::dump                    > vreg26:
 TRACE regalloc2::ion::dump                    > vreg27:
 TRACE regalloc2::ion::dump                    > vreg28:
 TRACE regalloc2::ion::dump                    > vreg29:
 TRACE regalloc2::ion::dump                    > vreg30:
 TRACE regalloc2::ion::dump                    > vreg31:
 TRACE regalloc2::ion::dump                    > vreg32:
 TRACE regalloc2::ion::dump                    > vreg33:
 TRACE regalloc2::ion::dump                    > vreg34:
 TRACE regalloc2::ion::dump                    > vreg35:
 TRACE regalloc2::ion::dump                    > vreg36:
 TRACE regalloc2::ion::dump                    > vreg37:
 TRACE regalloc2::ion::dump                    > vreg38:
 TRACE regalloc2::ion::dump                    > vreg39:
 TRACE regalloc2::ion::dump                    > vreg40:
 TRACE regalloc2::ion::dump                    > vreg41:
 TRACE regalloc2::ion::dump                    > vreg42:
 TRACE regalloc2::ion::dump                    > vreg43:
 TRACE regalloc2::ion::dump                    > vreg44:
 TRACE regalloc2::ion::dump                    > vreg45:
 TRACE regalloc2::ion::dump                    > vreg46:
 TRACE regalloc2::ion::dump                    > vreg47:
 TRACE regalloc2::ion::dump                    > vreg48:
 TRACE regalloc2::ion::dump                    > vreg49:
 TRACE regalloc2::ion::dump                    > vreg50:
 TRACE regalloc2::ion::dump                    > vreg51:
 TRACE regalloc2::ion::dump                    > vreg52:
 TRACE regalloc2::ion::dump                    > vreg53:
 TRACE regalloc2::ion::dump                    > vreg54:
 TRACE regalloc2::ion::dump                    > vreg55:
 TRACE regalloc2::ion::dump                    > vreg56:
 TRACE regalloc2::ion::dump                    > vreg57:
 TRACE regalloc2::ion::dump                    > vreg58:
 TRACE regalloc2::ion::dump                    > vreg59:
 TRACE regalloc2::ion::dump                    > vreg60:
 TRACE regalloc2::ion::dump                    > vreg61:
 TRACE regalloc2::ion::dump                    > vreg62:
 TRACE regalloc2::ion::dump                    > vreg63:
 TRACE regalloc2::ion::dump                    > vreg64:
 TRACE regalloc2::ion::dump                    > vreg65:
 TRACE regalloc2::ion::dump                    > vreg66:
 TRACE regalloc2::ion::dump                    > vreg67:
 TRACE regalloc2::ion::dump                    > vreg68:
 TRACE regalloc2::ion::dump                    > vreg69:
 TRACE regalloc2::ion::dump                    > vreg70:
 TRACE regalloc2::ion::dump                    > vreg71:
 TRACE regalloc2::ion::dump                    > vreg72:
 TRACE regalloc2::ion::dump                    > vreg73:
 TRACE regalloc2::ion::dump                    > vreg74:
 TRACE regalloc2::ion::dump                    > vreg75:
 TRACE regalloc2::ion::dump                    > vreg76:
 TRACE regalloc2::ion::dump                    > vreg77:
 TRACE regalloc2::ion::dump                    > vreg78:
 TRACE regalloc2::ion::dump                    > vreg79:
 TRACE regalloc2::ion::dump                    > vreg80:
 TRACE regalloc2::ion::dump                    > vreg81:
 TRACE regalloc2::ion::dump                    > vreg82:
 TRACE regalloc2::ion::dump                    > vreg83:
 TRACE regalloc2::ion::dump                    > vreg84:
 TRACE regalloc2::ion::dump                    > vreg85:
 TRACE regalloc2::ion::dump                    > vreg86:
 TRACE regalloc2::ion::dump                    > vreg87:
 TRACE regalloc2::ion::dump                    > vreg88:
 TRACE regalloc2::ion::dump                    > vreg89:
 TRACE regalloc2::ion::dump                    > vreg90:
 TRACE regalloc2::ion::dump                    > vreg91:
 TRACE regalloc2::ion::dump                    > vreg92:
 TRACE regalloc2::ion::dump                    > vreg93:
 TRACE regalloc2::ion::dump                    > vreg94:
 TRACE regalloc2::ion::dump                    > vreg95:
 TRACE regalloc2::ion::dump                    > vreg96:
 TRACE regalloc2::ion::dump                    > vreg97:
 TRACE regalloc2::ion::dump                    > vreg98:
 TRACE regalloc2::ion::dump                    > vreg99:
 TRACE regalloc2::ion::dump                    > vreg100:
 TRACE regalloc2::ion::dump                    > vreg101:
 TRACE regalloc2::ion::dump                    > vreg102:
 TRACE regalloc2::ion::dump                    > vreg103:
 TRACE regalloc2::ion::dump                    > vreg104:
 TRACE regalloc2::ion::dump                    > vreg105:
 TRACE regalloc2::ion::dump                    > vreg106:
 TRACE regalloc2::ion::dump                    > vreg107:
 TRACE regalloc2::ion::dump                    > vreg108:
 TRACE regalloc2::ion::dump                    > vreg109:
 TRACE regalloc2::ion::dump                    > vreg110:
 TRACE regalloc2::ion::dump                    > vreg111:
 TRACE regalloc2::ion::dump                    > vreg112:
 TRACE regalloc2::ion::dump                    > vreg113:
 TRACE regalloc2::ion::dump                    > vreg114:
 TRACE regalloc2::ion::dump                    > vreg115:
 TRACE regalloc2::ion::dump                    > vreg116:
 TRACE regalloc2::ion::dump                    > vreg117:
 TRACE regalloc2::ion::dump                    > vreg118:
 TRACE regalloc2::ion::dump                    > vreg119:
 TRACE regalloc2::ion::dump                    > vreg120:
 TRACE regalloc2::ion::dump                    > vreg121:
 TRACE regalloc2::ion::dump                    > vreg122:
 TRACE regalloc2::ion::dump                    > vreg123:
 TRACE regalloc2::ion::dump                    > vreg124:
 TRACE regalloc2::ion::dump                    > vreg125:
 TRACE regalloc2::ion::dump                    > vreg126:
 TRACE regalloc2::ion::dump                    > vreg127:
 TRACE regalloc2::ion::dump                    > vreg128:
 TRACE regalloc2::ion::dump                    > vreg129:
 TRACE regalloc2::ion::dump                    > vreg130:
 TRACE regalloc2::ion::dump                    > vreg131:
 TRACE regalloc2::ion::dump                    > vreg132:
 TRACE regalloc2::ion::dump                    > vreg133:
 TRACE regalloc2::ion::dump                    > vreg134:
 TRACE regalloc2::ion::dump                    > vreg135:
 TRACE regalloc2::ion::dump                    > vreg136:
 TRACE regalloc2::ion::dump                    > vreg137:
 TRACE regalloc2::ion::dump                    > vreg138:
 TRACE regalloc2::ion::dump                    > vreg139:
 TRACE regalloc2::ion::dump                    > vreg140:
 TRACE regalloc2::ion::dump                    > vreg141:
 TRACE regalloc2::ion::dump                    > vreg142:
 TRACE regalloc2::ion::dump                    > vreg143:
 TRACE regalloc2::ion::dump                    > vreg144:
 TRACE regalloc2::ion::dump                    > vreg145:
 TRACE regalloc2::ion::dump                    > vreg146:
 TRACE regalloc2::ion::dump                    > vreg147:
 TRACE regalloc2::ion::dump                    > vreg148:
 TRACE regalloc2::ion::dump                    > vreg149:
 TRACE regalloc2::ion::dump                    > vreg150:
 TRACE regalloc2::ion::dump                    > vreg151:
 TRACE regalloc2::ion::dump                    > vreg152:
 TRACE regalloc2::ion::dump                    > vreg153:
 TRACE regalloc2::ion::dump                    > vreg154:
 TRACE regalloc2::ion::dump                    > vreg155:
 TRACE regalloc2::ion::dump                    > vreg156:
 TRACE regalloc2::ion::dump                    > vreg157:
 TRACE regalloc2::ion::dump                    > vreg158:
 TRACE regalloc2::ion::dump                    > vreg159:
 TRACE regalloc2::ion::dump                    > vreg160:
 TRACE regalloc2::ion::dump                    > vreg161:
 TRACE regalloc2::ion::dump                    > vreg162:
 TRACE regalloc2::ion::dump                    > vreg163:
 TRACE regalloc2::ion::dump                    > vreg164:
 TRACE regalloc2::ion::dump                    > vreg165:
 TRACE regalloc2::ion::dump                    > vreg166:
 TRACE regalloc2::ion::dump                    > vreg167:
 TRACE regalloc2::ion::dump                    > vreg168:
 TRACE regalloc2::ion::dump                    > vreg169:
 TRACE regalloc2::ion::dump                    > vreg170:
 TRACE regalloc2::ion::dump                    > vreg171:
 TRACE regalloc2::ion::dump                    > vreg172:
 TRACE regalloc2::ion::dump                    > vreg173:
 TRACE regalloc2::ion::dump                    > vreg174:
 TRACE regalloc2::ion::dump                    > vreg175:
 TRACE regalloc2::ion::dump                    > vreg176:
 TRACE regalloc2::ion::dump                    > vreg177:
 TRACE regalloc2::ion::dump                    > vreg178:
 TRACE regalloc2::ion::dump                    > vreg179:
 TRACE regalloc2::ion::dump                    > vreg180:
 TRACE regalloc2::ion::dump                    > vreg181:
 TRACE regalloc2::ion::dump                    > vreg182:
 TRACE regalloc2::ion::dump                    > vreg183:
 TRACE regalloc2::ion::dump                    > vreg184:
 TRACE regalloc2::ion::dump                    > vreg185:
 TRACE regalloc2::ion::dump                    > vreg186:
 TRACE regalloc2::ion::dump                    > vreg187:
 TRACE regalloc2::ion::dump                    > vreg188:
 TRACE regalloc2::ion::dump                    > vreg189:
 TRACE regalloc2::ion::dump                    > vreg190:
 TRACE regalloc2::ion::dump                    > vreg191:
 TRACE regalloc2::ion::dump                    > vreg192:
 TRACE regalloc2::ion::dump                    > vreg193:
 TRACE regalloc2::ion::dump                    > vreg194:
 TRACE regalloc2::ion::dump                    >  * range progpoint0-post -- progpoint1-post: range0
 TRACE regalloc2::ion::dump                    > Ranges:
 TRACE regalloc2::ion::dump                    > range0: range=CodeRange { from: progpoint0-post, to: progpoint1-post } vreg=VRegIndex(194) bundle=LiveBundleIndex(0) weight=SpillWeight(8000.0)
 TRACE regalloc2::ion::dump                    >  * use at progpoint0-post (slot 0): Def: v194i reg
 TRACE regalloc2::ion::dump                    >  * use at progpoint1-pre (slot 0): Use: v194i fixed(p0i)
 TRACE regalloc2::ion::process                 > process_bundle: bundle LiveBundleIndex(0) hint PReg(hw = 63, class = Int, index = 63)
 TRACE regalloc2::ion::requirement             > compute_requirement: LiveBundleIndex(0)
 TRACE regalloc2::ion::requirement             >  -> LR LiveRangeIndex(0): CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::requirement             >   -> use Use { operand: Def: v194i reg, pos: progpoint0-post, slot: 0, weight: 35640 }
 TRACE regalloc2::ion::requirement             >      -> req Register
 TRACE regalloc2::ion::requirement             >   -> use Use { operand: Use: v194i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 }
 TRACE regalloc2::ion::requirement             >      -> req FixedReg(PReg(hw = 0, class = Int, index = 0))
 TRACE regalloc2::ion::requirement             >  -> final: FixedReg(PReg(hw = 0, class = Int, index = 0))
 TRACE regalloc2::ion::process                 > attempt 1, req FixedReg(PReg(hw = 0, class = Int, index = 0))
 TRACE regalloc2::ion::process                 > trying preg PRegIndex(0)
 TRACE regalloc2::ion::process                 > try_to_allocate_bundle_to_reg: LiveBundleIndex(0) -> PRegIndex(0)
 TRACE regalloc2::ion::process                 > alloc map for PRegIndex(0) in range LiveRangeKey { from: 1, to: 1 }..: {}
 TRACE regalloc2::ion::process                 >  -> range LR LiveRangeIndex(0): CodeRange { from: progpoint0-post, to: progpoint1-post }
 TRACE regalloc2::ion::process                 >   -> PReg range None
 TRACE regalloc2::ion::process                 >  -> no more PReg allocations; so no conflict possible!
 TRACE regalloc2::ion::process                 >   -> bundle LiveBundleIndex(0) assigned to preg PReg(hw = 0, class = Int, index = 0)
 TRACE regalloc2::ion::process                 >  -> allocated to any PRegIndex(0)
 TRACE regalloc2::ion::spill                   > allocating regs for spilled bundles
 TRACE regalloc2::ion::spill                   > allocate spillslot: 0
 TRACE regalloc2::ion::spill                   > spillslot allocator done
 TRACE regalloc2::ion::moves                   > apply_allocations_and_insert_moves
 TRACE regalloc2::ion::moves                   > blockparam_ins: []
 TRACE regalloc2::ion::moves                   > blockparam_outs: []
 TRACE regalloc2::ion::moves                   > get_alloc_for_range: LiveRangeIndex(0)
 TRACE regalloc2::ion::moves                   >  -> bundle: LiveBundleIndex(0)
 TRACE regalloc2::ion::moves                   >  -> allocation p0i
 TRACE regalloc2::ion::moves                   > apply_allocations: vreg VRegIndex(194) LR LiveRangeIndex(0) with range CodeRange { from: progpoint0-post, to: progpoint1-post } has alloc p0i
 TRACE regalloc2::ion::moves                   > applying to use: Use { operand: Def: v194i reg, pos: progpoint0-post, slot: 0, weight: 35640 }
 TRACE regalloc2::ion::moves                   > applying to use: Use { operand: Use: v194i fixed(p0i), pos: progpoint1-pre, slot: 0, weight: 35447 }
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Register allocation: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode emission, (during Compilation passes)
 TRACE cranelift_codegen::machinst::buffer     > MachBuffer: first 1 labels are for blocks
 TRACE cranelift_codegen::machinst::vcode      > emitting block Block(0)
 TRACE cranelift_codegen::machinst::vcode      >  -> entry block
 TRACE cranelift_codegen::machinst::buffer     > MachBuffer: bind label MachLabel(0) at offset 4
 TRACE cranelift_codegen::machinst::buffer     > enter optimize_branches:
 b = []
 l = [MachLabel(0)]
 f = []
 TRACE cranelift_codegen::machinst::buffer     > leave optimize_branches:
 b = []
 l = [MachLabel(0)]
 f = []
 TRACE cranelift_codegen::machinst::abi        > Epilogue: [movq    %rbp, %rsp, popq    %rbp, ret]
 TRACE cranelift_codegen::machinst::buffer     > enter optimize_branches:
 b = []
 l = []
 f = []
 TRACE cranelift_codegen::machinst::buffer     > leave optimize_branches:
 b = []
 l = []
 f = []
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting VCode emission finalization, (during VCode emission)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode emission finalization: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending VCode emission: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Compilation passes: 1ms
 INFO  cranelift_jit::backend                  > defining function funcid3: function u0:3(i16) -> i64 system_v {
block0(v1: i16):
    v2 = uextend.i32 v1
    v3 = uextend.i64 v2
    return v3
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Compilation passes, (during <no pass>)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::context              > Number of CLIF instructions to optimize: 3
 DEBUG cranelift_codegen::context              > Number of CLIF blocks to optimize: 1
 TRACE cranelift_codegen::context              > Optimizing (opt level Speed):
function u0:3(i16) -> i64 system_v {
block0(v1: i16):
    v2 = uextend.i32 v1
    v3 = uextend.i64 v2
    return v3
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 TRACE cranelift_codegen::legalizer            > Pre-legalization function:
function u0:3(i16) -> i64 system_v {
block0(v1: i16):
    v2 = uextend.i32 v1
    v3 = uextend.i64 v2
    return v3
}

 TRACE cranelift_codegen::legalizer            > Post-legalization function:
function u0:3(i16) -> i64 system_v {
block0(v1: i16):
    v2 = uextend.i32 v1
    v3 = uextend.i64 v2
    return v3
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Remove unreachable blocks, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove unreachable blocks: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dead code elimination, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dead code elimination: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Remove constant phi-nodes, (during Compilation passes)
 DEBUG cranelift_codegen::remove_constant_phis > do_remove_constant_phis: done, 1 iters.   0 formals, of which 0 const.
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Remove constant phi-nodes: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Verify Cranelift IR, (during Compilation passes)
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Control flow graph, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Control flow graph: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Dominator tree, (during Verify Cranelift IR)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Dominator tree: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Verify Cranelift IR: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Egraph based optimizations, (during Compilation passes)
 TRACE cranelift_codegen::context              > About to optimize with egraph phase:
function u0:3(i16) -> i64 system_v {
block0(v1: i16):
    v2 = uextend.i32 v1
    v3 = uextend.i64 v2
    return v3
}

 DEBUG cranelift_codegen::timing::enabled      > timing: Starting Loop analysis, (during Egraph based optimizations)
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Loop analysis: 0ms
 TRACE cranelift_codegen::alias_analysis       > alias analysis: input is:
function u0:3(i16) -> i64 system_v {
block0(v1: i16):
    v2 = uextend.i32 v1
    v3 = uextend.i64 v2
    return v3
}

 TRACE cranelift_codegen::alias_analysis       > alias analysis: input to block0 is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst0: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst1: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::alias_analysis       > after inst2: state is LastStores { heap: None, table: None, vmctx: None, other: None }
 TRACE cranelift_codegen::egraph               > Processing block block0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for blockparam v1
 TRACE cranelift_codegen::egraph               > Processing inst inst0
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v2
 TRACE cranelift_codegen::egraph               > rewriting arg v1 of inst inst0 to v1
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v2
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i32
 TRACE cranelift_codegen::opts                 > iter: value v1
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v2 -> [v2]
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst1
 TRACE cranelift_codegen::egraph               > creating initial singleton eclass for v3
 TRACE cranelift_codegen::egraph               > rewriting arg v2 of inst inst1 to v2
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 1
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v3
 TRACE cranelift_codegen::opts                 > iter: value v3
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > iter: value v2
 TRACE cranelift_codegen::opts                 >  -> value of type i32
 TRACE cranelift_codegen::egraph               > Incrementing rewrite depth; now 2
 TRACE cranelift_codegen::egraph               > Calling into ISLE with original value v4
 TRACE cranelift_codegen::opts                 > iter: value v4
 TRACE cranelift_codegen::opts                 >  -> value of type i64
 TRACE cranelift_codegen::opts                 > iter: value v1
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v4 -> [v4]
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 1
 TRACE cranelift_codegen::opts                 > make_inst_ctor: Unary { opcode: Uextend, arg: v1 } -> v4
 TRACE cranelift_codegen::egraph               >   -> returned from ISLE: v3 -> [v4, v3]
 TRACE cranelift_codegen::egraph               > Returned from ISLE for v3, got v4
 TRACE cranelift_codegen::egraph               >  -> union: now v5
 TRACE cranelift_codegen::unionfind            > union: v3, v4
 TRACE cranelift_codegen::unionfind            > union: v3, v5
 TRACE cranelift_codegen::egraph               > Decrementing rewrite depth; now 0
 TRACE cranelift_codegen::egraph               > Processing inst inst2
 TRACE cranelift_codegen::egraph               > rewriting arg v3 of inst inst2 to v5
 TRACE cranelift_codegen::alias_analysis       > alias analysis: scanning at inst2 with state LastStores { heap: None, table: None, vmctx: None, other: None } (MultiAry { opcode: Return, args: EntityList { index: 13, unused: PhantomData<cranelift_codegen::ir::entities::Value> } })
 TRACE cranelift_codegen::egraph               > egraph built:
function u0:3(i16) -> i64 system_v {
block0(v1: i16):
    return v5
}


 TRACE cranelift_codegen::egraph               >  -> v1 = Param(block0, 0)
 TRACE cranelift_codegen::egraph               >  -> v2 = Result(inst0, 0)
 TRACE cranelift_codegen::egraph               >   -> inst0 = Unary { opcode: Uextend, arg: v1 }
 TRACE cranelift_codegen::egraph               >  -> v3 = Result(inst1, 0)
 TRACE cranelift_codegen::egraph               >   -> inst1 = Unary { opcode: Uextend, arg: v2 }
 TRACE cranelift_codegen::egraph               >  -> v4 = Result(inst3, 0)
 TRACE cranelift_codegen::egraph               >   -> inst3 = Unary { opcode: Uextend, arg: v1 }
 TRACE cranelift_codegen::egraph               >  -> v5 = Union(v3, v4)
 TRACE cranelift_codegen::egraph               > stats: Stats {
    pure_inst: 3,
    pure_inst_deduped: 0,
    skeleton_inst: 1,
    alias_analysis_removed: 0,
    new_inst: 1,
    union: 1,
    subsume: 0,
    remat: 0,
    rewrite_rule_invoked: 3,
    rewrite_depth_limit: 0,
    elaborate_visit_node: 0,
    elaborate_memoize_hit: 0,
    elaborate_memoize_miss: 0,
    elaborate_remat: 0,
    elaborate_licm_hoist: 0,
    elaborate_func: 0,
    elaborate_func_pre_insts: 0,
    elaborate_func_post_insts: 0,
    elaborate_best_cost_fixpoint_iters: 0,
}
 TRACE cranelift_codegen::egraph               > pinned_union_count: 0
 TRACE cranelift_codegen::egraph::elaborate    > Entering fixpoint loop to compute the best values for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 0
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v2 = Cost::Finite { op_cost: 2, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v3 def Result(inst1, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v3 = Cost::Finite { op_cost: 4, depth: 2 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v4 def Result(inst3, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v4 = Cost::Finite { op_cost: 2, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v5 def Union(v3, v4)
 TRACE cranelift_codegen::egraph::elaborate    >  -> best of union(BestEntry(Cost::Finite { op_cost: 4, depth: 2 }, v3), BestEntry(Cost::Finite { op_cost: 2, depth: 1 }, v4)) = BestEntry(Cost::Finite { op_cost: 2, depth: 1 }, v4)
 TRACE cranelift_codegen::egraph::elaborate    > fixpoint iteration 1
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v1 def Param(block0, 0)
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v2 def Result(inst0, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v2 = Cost::Finite { op_cost: 2, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v3 def Result(inst1, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v3 = Cost::Finite { op_cost: 4, depth: 2 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v4 def Result(inst3, 0)
 TRACE cranelift_codegen::egraph::elaborate    >  -> cost of value v4 = Cost::Finite { op_cost: 2, depth: 1 }
 TRACE cranelift_codegen::egraph::elaborate    > computing best for value v5 def Union(v3, v4)
 TRACE cranelift_codegen::egraph::elaborate    >  -> best of union(BestEntry(Cost::Finite { op_cost: 4, depth: 2 }, v3), BestEntry(Cost::Finite { op_cost: 2, depth: 1 }, v4)) = BestEntry(Cost::Finite { op_cost: 2, depth: 1 }, v4)
 TRACE cranelift_codegen::egraph::elaborate    > finished fixpoint loop to compute best value for each eclass
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v1: BestEntry(Cost::Finite { op_cost: 0, depth: 0 }, v1)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v2: BestEntry(Cost::Finite { op_cost: 2, depth: 1 }, v2)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v3: BestEntry(Cost::Finite { op_cost: 4, depth: 2 }, v3)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v4: BestEntry(Cost::Finite { op_cost: 2, depth: 1 }, v4)
 TRACE cranelift_codegen::egraph::elaborate    > -> best for eclass v5: BestEntry(Cost::Finite { op_cost: 2, depth: 1 }, v4)
 TRACE cranelift_codegen::egraph::elaborate    >  -> Terminator elab arg v5 is best value is v4
thread 'main' panicked at cranelift/codegen/src/egraph/elaborate.rs:875:22:
called `Option::unwrap()` on a `None` value
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Egraph based optimizations: 0ms
 DEBUG cranelift_codegen::timing::enabled      > timing: Ending Compilation passes: 0ms
